We hold the entire init file in Org mode to allow increased comments, along with better organization. This further gives the easy ability to debug by disabling select components of the init.
This is connected to a github page.

Idea: set a separate file with a set of variable assignments like specific paths, and names and passwords. Then have this file load it to allow a secure posting. 
  
First Steps
#+BEGIN_SRC emacs-lisp
;; Turn off mouse interface early in startup to avoid momentary display
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
;; No splash screen please ... jeez
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
;; The error bell is really annoying
(setq ring-bell-function 'ignore)
;; We want emacs to work like the terminal version for maximum consistancy. This is where brew puts its formula
(setq exec-path (append exec-path '("/usr/local/bin"))) ;for internal functions
(setenv "PATH" (concat "/usr/local/bin/:" (getenv "PATH"))) ;for shell exicution
;;Fringes are not space efficiant
(set-fringe-mode 0)
#+END_SRC
  
We ensure that packages are installed by using the use-package package, so we require that melpa is hooked up and that use-package is installed
#+BEGIN_SRC emacs-lisp
;;;-*- lexical-binding: t -*-
(require 'package)
(setq package-archives '(
			 ("elpa" . "http://tromey.com/elpa/")
			 ("gnu" . "http://elpa.gnu.org/packages/")
			 ("melpa" . "https://melpa.org/packages/")
			 ))
(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))
(unless (package--user-selected-p 'use-package)
  (package-install 'use-package)
  )
(eval-and-compile
  (require 'use-package))
#+END_SRC 

We set the custom package to it's own file, instead of polluting our.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
(unless (file-exists-p custom-file)
  (write-region "" "" custom-file))
(load custom-file)
#+END_SRC

We apply the dracula theme.
We setup preferences for the mode-line:
I turn on battery and time displays, setup smart-mode-line (ssl) and disable the menu-bar.
#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :ensure t
  :config
  (load-theme 'kaolin-galaxy t)
  )

(setq display-time-default-load-average nil); must be assigned before (display-time-mode 1) is called
(setq display-time-24hr-format t)
(setq display-time-day-and-date t)
(display-time-mode 1); does not change in real time, so all settings must be assigned before

(display-battery-mode 1)

(use-package smart-mode-line
  :ensure t
  :hook (after-init . sml/setup)
  :config
  (setq sml/no-confirm-load-theme t)
  (setq sml/theme 'respectful) ;conforms to main emacs theme, set to nil to allow default colors
  (defface sml/charging ;this is much easier to see
    '((t :inherit sml/global :foreground "green")) "" :group 'smart-mode-line-faces)
  (add-to-list 'sml/replacer-regexp-list '("^~/Google Drive/" ":GDrive:") t) ;re replacement Google Drive -> GDrive
  (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox" ":DBox:") t) ;re replacement Drop Box -> DBox
  )

#+END_SRC

Sets up universal variables to be used later
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

I'm trying out EVIL, because reasons.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :config
  ;; This should make the insert state effectively the default (emacs) state
  (setq evil-disable-insert-state-bindings t)
  (setq evil-default-state 'emacs)
  (evil-mode 0)
  )

(use-package undo-tree
  :config
  (global-undo-tree-mode 0)
  )
#+END_SRC
 
Creates a set of universal functions that are called by varios major modes
We use my-prog-mode-called as a flag to indicate wither we load my-prog-mode again
#+BEGIN_SRC emacs-lisp
(setq my-prog-mode-called nil)
(defun my-prog-mode ()
  (when (equal my-prog-mode-called nil)
    (global-set-key (kbd "C-c q") 'comment-or-uncomment-region)
    (setq display-line-numbers t)
    (line-number-mode 0)
    (column-number-mode 1)
    (if (version<= "26.0.50" emacs-version) 
	(global-display-line-numbers-mode 1) ; displays line numbers on the left
      (linum-mode 1) ; display-line-numbers-mode was added in v26, so if earlier, we default to linum-mode
      )
    (flyspell-prog-mode) ;this tells flyspell to not complain about variable names
    (eldoc-mode 1)
    (setq company-minimum-prefix-length 1) ;we want an active company for programming, as there are many variable names, and memory is hard
    (setq font-lock-maximum-decoration t) ;lots of syntax highlighting
    (subword-mode t)
    (setq my-prog-mode-called t)
    (message "%s" (concat
		   "my-prog-mode was called successfully on major mode: "
		   (symbol-name major-mode)))
    ))
(defun call-my-prog-mode ()
  (interactive)
  (setq my-prog-mode-called nil)
  (my-prog-mode)
  )

(defun my-text-mode ()
  (wc-mode 1)               ; provides a word count
  (flyspell-mode 1)         ; recognizes misspellings
  (visual-line-mode 1)      ; we want the words to wrap
  (setq tab-width 4)
  (message "%s" "my-text-mode was called successfully.")
  )

(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting. From http://whattheemacsd.com/"
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC


There is a collection of minor modes that trigger after other major modes load.
- saveplace has reopened files remember the mark position
- ace-window allows a multi-window mode (vim style)
- zoom changes window layout on crowded screens to show more of the selected window
- pending-delete-mode gives autodeletion on the region
- company-math gives a LaTeX style backend for LaTeX and markdown
- wc-mode provides a word count in the mode line
- electric operators provide spacing for prog modes that lack a util to prettify code
- define-word shows a word definition at point or on lookup
- magit is a git wrapper
- helm and helm-company provide fuzzy completion on system searches
- smartparens gives (semi) smart paired symbol insertion
#+BEGIN_SRC emacs-lisp

;; Save point position between sessions
(require 'saveplace)
(save-place-mode 1)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

(use-package expand-region
  :ensure t
  :bind (("C-=" . 'er/expand-region))
  )


(use-package ace-window
  :ensure t
  :bind (("M-o" . ace-window))
  )

(use-package zoom
  :ensure t
  :config
  (zoom-mode 1)
  )

;; typing replaces the active region
(pending-delete-mode +1)

;;Word-count gives a total and diffrenced word count in the mode line
(use-package wc-mode
  :ensure t
  :hook ((LaTeX-mode ess-mode markdown-mode) . wc-mode)
  :config
  (wc-mode 1)
  )

;;electric-operator adds spaces before and after opperator symbols
(use-package electric-operator
  :ensure t
  :hook ((ess-mode LaTeX-mode) . electric-operator-mode)
  :config
  )

(use-package define-word
  :ensure t
  :config
  (global-set-key (kbd "C-c d") 'define-word-at-point)
  (global-set-key (kbd "C-c D") 'define-word)
  )

(use-package magit
  :ensure t
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  )

(use-package smartparens
  :ensure t
  :config
  (sp-pair "(" ")" :unless '(sp-point-before-word-p))
  (add-hook 'c-mode-hook (lambda () (sp-pair "'" nil :actions :rem)))
  (add-hook 'emacs-lisp-mode-hook (lambda () (sp-pair "'" nil :actions :rem)))
  (smartparens-global-mode +1)
  )

#+END_SRC

I use helm for fuzzy searching among known options
#+BEGIN_SRC emacs-lisp

(use-package helm
  :ensure t
  :config
  (helm-mode 1)
  (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-s") 'helm-occur)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  )

(use-package helm-company
  :ensure t
  :after (company helm)
  :config
  (define-key company-mode-map (kbd "C-;") 'helm-company)
  (define-key company-active-map (kbd "C-;") 'helm-company)
  )

#+END_SRC



We maintain a list of common key-bindings to activate in all modes
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-r") 'scroll-down)
(global-set-key (kbd "C-v") 'scroll-up)
(global-set-key (kbd "C-l") 'forward-word)
(global-set-key (kbd "C-j") 'backward-word)
(global-set-key (kbd "M-f") 'forward-sentence)
(global-set-key (kbd "M-b") 'backward-sentence)
(global-set-key (kbd "C-z") 'ispell-word)
(global-set-key (kbd "M--") 'undo)
(global-set-key (kbd "C-M-n")
  		(lambda ()
		  (interactive)
		  (ignore-errors (next-line 5))))
(global-set-key (kbd "C-M-p")
  		(lambda ()
  		  (interactive)
  		  (ignore-errors (previous-line 5))))
(global-set-key (kbd "s-t") 'make-frame) ;this allows cmd-t to be consistant
(global-set-key (kbd "s-w") 'delete-frame)
(global-set-key (kbd "s-<return>") 'toggle-frame-fullscreen)

(global-set-key (kbd "C-M-v") 'scroll-other-window-down)
(global-set-key (kbd "C-M-r") 'scroll-other-window)


#+END_SRC


ido provides a great navigation experience with the find-file command. 
vlf stands for very large files and assists emacs with handling large files
FIXME: Im not sure is vlf is configured correctly
#+BEGIN_SRC emacs-lisp

;; Interactively Do Things
(use-package ido
  :disabled
  :ensure t
  :config
  (ido-mode t)
  )
(setq read-file-name-completion-ignore-case nil)

;;Very Large Files
(use-package vlf
  :ensure t
  :config
  (require 'vlf-setup) ;not a seperate package, just pre-loading
  (custom-set-variables
   '(vlf-application 'dont-ask))
  )
#+END_SRC

Org mode provides a function text mode, so we give it many text mode type things.
Note: htmlize allows org-mode to publish to html more complex stuff like src blocks. 
#+BEGIN_SRC emacs-lisp

(use-package htmlize
  :ensure t
  )


(defun my-org-mode()
  (setq org-babel-python-command "python3")
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t) (emacs-lisp . t)))
  (when (equal (buffer-file-name)
	       (expand-file-name (concat user-emacs-directory "init.org")))
    (my-prog-mode)
    )
  (local-set-key (kbd "C-j") 'backward-word)
  (my-text-mode)
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-preserve-indentation t)
  (defvar  *src-default-language* nil)
  (defun src-default-language ()
    (interactive)
    (setq *src-default-language* (read-string "Language: ")))
  (define-skeleton skeleton-src-block
    "Inserts a SRC Block Letter into the buffer"
    ""
    "#+BEGIN_SRC " (if *src-default-language* *src-default-language* (skeleton-read "Language: ")) "\n"
    "\n"
    "#+END_SRC"
    )
  (setenv "PATH" (concat "/Library/TeX/texbin/:" (getenv "PATH"))); to allow LaTeX output from org-mdoe
  (yas-activate-extra-mode 'text-mode)
  (message "%s" "Org mode called successfully.")
  )
(add-hook 'org-mode-hook #'my-org-mode)
#+END_SRC

Sets all backups to path to .emacs.d instead of cluttering the folder their in
#+BEGIN_SRC emacs-lisp
;; sets autosaves to one folder
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
 
;; Write backup files to own directory
(setq backup-directory-alist
      `(("." . ,(expand-file-name
		 (concat user-emacs-directory "backups")))))

;; Make backups of files, even when they're in version control
(setq vc-make-backup-files t)
#+END_SRC

Company is used for auto-completions. In the spirit of emacs, it can be customized for almost any language, but those customizations are module specific. Here, we only call the main version.
#+BEGIN_SRC emacs-lisp

(use-package company
  :ensure t
  :init
  ;; mini version of a hook for adding a company backend'
  (defun add-company-backend (backend)
    ;; (add-to-list 'company-backends `(,symbol-list . '(:with company-yasnippet)))
	(add-to-list 'company-backends (append (if (consp backend) backend (list backend))
		'(:with company-yasnippet)))
    )
  :config
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay 0.1) ; this makes company respond in real time (no delay)
  (setq company-dabbrev-downcase 0) ; this makes it so company correctly gives cases
  (global-company-mode t)
  :bind (:map company-active-map
  	      ("<return>" . nil)
	      ("RET" . nil)
  	      ("C-@" . #'company-complete-selection) ;also means space
	      ("C-SPC" . #'company-complete-selection)
	      ("C-<space>" . #'company-complete-selection)
	      ("M-p" . #'company-select-previous-or-abort)
	      ("M-n" . #'company-select-next-or-abort))
  )

(use-package company-flx
  :ensure t
  :after (company)
  :config
  (company-flx-mode +1)
  )

;;Company-math provides auto-complete for math symbols
(use-package company-math
  :ensure t
  :after (company (:any auctex markdown))
  :config
  (add-company-backend 'company-math)
  )

#+END_SRC


yasnippet allows snippet expansion
Snippets are kept in the folder described by "yas-snippet-dirs"
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (defun setup-yas-company () 
    (defvar company-mode/enable-yas t
      "Enable yasnippet for all backends.")

    (defun company-mode/backend-with-yas (backend)
      (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
	  backend
	(append (if (consp backend) backend (list backend))
		'(:with company-yasnippet))))

    (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
    )
  :config
  (setup-yas-company)
  (yas-global-mode 1)
)

#+END_SRC



ESS or Emacs Speaks Statistics is a major mode that I use to handle R. It could be extended to handle other S type stat languages in the future. 
#+BEGIN_SRC emacs-lisp
(use-package ess
  :mode (("\\.r\\'" . ess-r-mode)
	 ("\\.R\\'" . ess-r-mode))  
  :ensure t
  :init
  (require 'ess-site)
  :config
  (setq inferior-ess-r-program "/usr/local/bin/R")
  ;; We assume the ability to generate graphs using a WindowsX(QuartsX) program.
  (setq ess-dialect "R")
  (setq ess-ask-for-ess-directory nil) ; directory defaults to whatever ess-directory-function returns
  (setq ess-directory-function nil) ; directory defaults to ess-directory
  (setq ess-directory nil) ; directory defaults to the directory of the opened file
  (add-hook 'inferior-ess-mode  'ess-execute-screen-options)
  )
#+END_SRC

I assign markdown to the appropriate extensions, and enable math-mode and wc-mode. I honestly don't use this much as org-mode does most of what markdown does.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
  	 ("\\.md\\'" . markdown-mode)
  	 ("\\.markdown\\'" . markdown-mode))
  :hook ((markdown-mode . (lambda ()
			    (yas-activate-extra-mode 'text-mode)
			    (display-line-numbers-mode -1)
			    (visual-line-mode 1))))
  :init
  (setq markdown-command "/usr/local/bin/multimarkdown")
  (setq markdown-enable-math t)
  :config
  (setq tab-width 4)
  (flyspell-mode +1)
  (message "%s" "Markdown mode was successfully called")
  )
#+END_SRC

I use sly as my lisp editor
#+BEGIN_SRC emacs-lisp
(use-package sly
  :defer t
  :mode (("\\.lisp\\'" . sly-mode))
  :hook ((sly-mode . (lambda () (prettify-symbols-mode +1)))) ;lambda is necessary to call with arguments
  :ensure t 
  :config
  ;; The check prevents setting a new editor at compile time
  (prettify-symbols-mode +1)
  (lisp-mode)
  (if (string-suffix-p ".lisp" buffer-file-name)
      (setq inferior-lisp-program "/usr/local/bin/clisp"))
  (define-key sly-prefix-map (kbd "M-h") 'sly-documentation-lookup)
  (my-prog-mode)
  (setq sly-lisp-implementations '(
	  (clisp ("/usr/local/bin/clisp"))
	  ))
  (setq sly-default-lisp 'clisp)
  (message "%s"  (concat "sly(slime) package loaded on major-mode: " (symbol-name major-mode)))
  (sly)
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-emacs-lisp-mode ()
  (prettify-symbols-mode +1)
  (my-prog-mode)
  )
(add-hook 'emacs-lisp-mode-hook #'my-emacs-lisp-mode)
#+END_SRC

Configure rust, enabling rust-mode, cargo-mode, flymake-rust, and company-racer.
#+BEGIN_SRC emacs-lisp
;;; Rust Minor Modes

;; rust plugin to enable flymake
(use-package flymake-rust
  :disabled ;;FIXME
  :ensure t
  :hook ((rust-mode . flymake-rust-load))
  :config
  (let ((rust-root-path (string-trim
			 (shell-command-to-string "rustc --print sysroot"))))
    (setq flymake-rust-use-cargo nil)
    (setq flymake-rust-executable (concat rust-root-path "/bin/cargo")))
  (message "%s" "flymake-rust has been enabled")
  )

;; Provides Cargo integration
(use-package cargo
  :ensure t
  :hook (rust-mode . cargo-minor-mode)
  :config
  (cargo-minor-mode 1)
  (setq cargo-process--enable-rust-backtrace t)
  (setq cargo-process--command-build "build --verbose")
  (setq cargo-process--command-run "run --verbose")
  (message "%s" "cargo has been enabled")
  )

;; Compamny integration with racer (rust backend completion client)
(use-package racer
  :ensure t
  :hook ((rust-mode . racer-mode)
	 (racer-mode-hook . eldoc-mode)
	 (racer-mode-hook . company-mode))
  :init
  (setq company-racer-executable "racer")
  :config
  (message "%s" "racer has been enabled.")
  )

;; Rust Major Mode
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode)
  :ensure t
  :init
  (setenv "PATH" (concat "~/.cargo/bin" ":"
			 (getenv "PATH")))
  (let ((rust-root-path (string-trim
		 (shell-command-to-string "rustc --print sysroot"))))
  (setq racer-rust-src-path
	(concat rust-root-path"/lib/rustlib/src/rust/src"))
  (setq rust-rustfmt-bin (concat rust-root-path "/bin/rustfmt")))
  :config
  (my-prog-mode)
  (setq rust-format-on-save t)
  (message "%s" "Rust mode was called successfully")
  )

#+END_SRC

Setup elpy to provide auto-complete, highlighting, indent guides, along with an inferior shell for writing python.
#+BEGIN_SRC emacs-lisp
;;; Python Minor Modes

;;pyenv mode - Virtual Enviroment Manager
(use-package pyenv-mode ;;FIXME
  :ensure t
  :after (elpy)
  :init
  (setenv "WORKON_HOME" "~/.pyenv/versions/")
  :config
  (pyenv-mode)
  )

;; Indentation Guide
(use-package highlight-indent-guides ;;FIXME
  :disabled
  :ensure t
  :after (elpy)
  :config
  (highlight-indentation-mode 0)
  (setq highlight-indent-guides-method 'column); could be "character", "fill", "column"
  (setq highlight-indent-guides-character ?\|) ;sets character of the highlight, if in character mode
  (setq highlight-indent-guides-responsive nil); options: 'top, 'stack, this dictates if and how it responds to the cursor position
  (setq highlight-indent-guides-delay 0); respond immediately to the cursor
  (setq highlight-indent-guides-auto-enabled nil) ;this means that I can set colors, t means that it will guess based on theme
  (set-face-background 'highlight-indent-guides-odd-face "darkcyan")
  (set-face-background 'highlight-indent-guides-even-face "darkcyan")
  (set-face-foreground 'highlight-indent-guides-character-face "dimgrey")
  (highlight-indent-guides-mode 1); turn on mode
  )

;; Setup Python3 shell
(defun set-shell-python3 ()
  (interactive)
  (setq python-shell-interpreter "python3")
  (setq python-shell-interpreter-args "-i")
  (with-eval-after-load 'python
    ;;This makes readline work in the interpreter
    (defun python-shell-completion-native-try ()
      "Return non-nil if can trigger native completion."
      (let ((python-shell-completion-native-enable t)
	    (python-shell-completion-native-output-timeout
	     python-shell-completion-native-try-output-timeout))
	(python-shell-completion-native-get-completions
	 (get-buffer-process (current-buffer))
	 nil "_"))))
  )

;; Setup iPython shell
(defun set-shell-ipython ()
  (interactive)
  (setq python-shell-interpreter "ipython")
  (setq python-shell-interpreter-args "--simple-prompt -i")
  )

;; Elpy specific key bingins
;; As Elpy does not conform to key-maps, we do it this way :bind does not work
(defun elpy-key-bindings ()
  (local-set-key (kbd "M-]") 'elpy-nav-indent-shift-right)
  (local-set-key (kbd "M-[") 'elpy-nav-indent-shift-left)
  (local-set-key (kbd "C-x p e") 'pyenv-activate-current-project)
  (local-set-key (kbd "M-p") 'elpy-nav-move-line-or-region-up)
  (local-set-key (kbd "M-n") 'elpy-nav-move-line-or-region-dowb)
  )
 
;;; Python Major Mode - Elpy
(use-package elpy
  :defer t
  :mode ("\\.py\\'" . python-mode)
  :hook ((python-mode . elpy-mode))
  :ensure t
  :init
  (setq python-indent-guess-indent-offset t)  
  (setq python-indent-guess-indent-offset-verbose nil)
  :config
  (my-prog-mode)
  (elpy-key-bindings)
  (add-hook 'before-save-hook #'elpy-format-code)
  (elpy-enable)
  (setq elpy-rpc-backend "company")
  (setq indent-tabs-mode nil)
  (setq elpy-rpc-python-command "python3")
  (setq elpy-syntax-check-command "/usr/local/bin/flake8")
  (elpy-rpc-restart)
  (set-shell-python3)
  (message "%s" (concat "Python mode was called successfully. major-mode: "
			(symbol-name major-mode)))
  )
#+END_SRC

Sets up latex support along with a collection of skeletons for latex. This is also mostly replaced by org-mode
#+BEGIN_SRC emacs-lisp

(defun latex-config ()
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (local-set-key "\C-j" 'backward-word)
  (display-line-numbers-mode)
  (visual-line-mode)
  (visual-line-mode)
  (define-skeleton skeleton-math-letter
    "Inserts a latex Letter Outline into the buffer"
    "Title: "
    "\\documentclass[11pt, oneside]{article}\n"
    "\\usepackage{geometry}\n"
    "\\geometry{letterpaper}\n"
    "\\usepackage{graphicx}\n"
    "\\usepackage{amssymb}\n"
    "\\usepackage{enumitem}\n"
    "\\usepackage{amsmath}\n"
    "\\usepackage{amsfonts}\n"
    "\\makeatletter\n"
    "\\newcommand{\\zz}{\\mathbb{Z}}\n"
    "\\newcommand{\\rr}{\\mathbb{R}}\n"
    "\\newcommand{\\cc}{\\mathbb{C}}\n"
    "\\newcommand{\\qq}{\\mathbb{Q}}\n"
    "\\newcommand{\\nsum}{\\sum^n_{i=1}}\n"
    "\\newcommand{\\exc}[1]{$ $\\\\\\noindent\\textbf{Problem #1}}\n"
    "\\newcommand{\\inpr}[2]{\\langle #1, #2\\rangle}\n"
    "\\newcommand{\\floor}[1]{\\lfloor #1 \\rfloor}\n"
    "\\newcommand{\\bmatrix}[1]{\\begin{bmatrix}#1\\end{bmatrix}}\n"
    "\\newcommand{\\fl}{{\\mathcal L}}\n"
    "\\newcommand{\\fu}{{\\mathcal U}}\n"
    "\\usepackage{tikz}\n"
    "\\title{" (skeleton-read "Title: ") "\n"
    "\\\\ \\large " (skeleton-read "Class: ") "}\n"
    "\\author{" user-full-name "}\n"
    "\\date{" (skeleton-read "Date: ") "}\n"
    "\\begin{document}\n"
    "\\maketitle\n"
    "$\n"
    "$\\\\\n"
    -
    "\n\n\n\\end{document}"
    )
  (message "%s" "LaTeX-mode has been loaded successfully")
  (setq font-latex-fontify-script nil) ;disables inline subscripts and superscripts
  )
(use-package tex
  :defer t
  :mode ("\\.tex\\'" . LaTeX-mode)
  :hook ((LaTeX-mode . latex-config) (LaTeX-mode . (lambda ()  (yas-activate-extra-mode 'text-mode))))
  :ensure auctex
  )
#+END_SRC 
 
We want init.org to have special behavior, specifically we want init.org to tangle to a .el file then byte compile for loading speed. 
The part that performed the byte-compile is currently disabled as it caused problems with use-package.
#+BEGIN_SRC emacs-lisp
(defun tangle-init-call ()
  (when (equal (buffer-file-name)
	       (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle-file buffer-file-name (concat user-emacs-directory "init.el"))
      ;; uncomment to byte compile init.el on save
      ;;(byte-compile-file (concat user-emacs-directory "init.el"))
      )
    )
  )
(add-hook 'after-save-hook 'tangle-init-call)
#+END_SRC

I use a font called Fira-Code. This enables the font as well as the font's ligatures. 
#+BEGIN_SRC emacs-lisp
(defun fira-code-mode--make-alist (list)
  "Generate prettify-symbols alist from LIST."
  (let ((idx -1))
    (mapcar
     (lambda (s)
       (setq idx (1+ idx))
       (let* ((code (+ #Xe100 idx))
          (width (string-width s))
          (prefix ())
          (suffix '(?\s (Br . Br)))
          (n 1))
     (while (< n width)
       (setq prefix (append prefix '(?\s (Br . Bl))))
       (setq n (1+ n)))
     (cons s (append prefix suffix (list (decode-char 'ucs code))))))
     list)))

(defconst fira-code-mode--ligatures
  '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    "!d!i!s!p!l!a!y!s!t!a!r!" ":" "+" "+" "*"))

(defvar fira-code-mode--old-prettify-alist)

(defun fira-code-mode--enable ()
  "Enable Fira Code ligatures in current buffer."
  (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
  (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
  (prettify-symbols-mode t))

(defun fira-code-mode--disable ()
  "Disable Fira Code ligatures in current buffer."
  (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
  (prettify-symbols-mode -1))

(define-minor-mode fira-code-mode
  "Fira Code ligatures minor mode"
  :lighter " Fira Code"
  (setq-local prettify-symbols-unprettify-at-point 'right-edge)
  (if fira-code-mode
      (fira-code-mode--enable)
    (fira-code-mode--disable)))

(defun fira-code-mode--setup ()
  "Setup Fira Code Symbols"
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

(provide 'fira-code-mode)


(when (and (window-system) (member "Fira Code" (font-family-list)))
  (set-frame-font "Fira Code")
  (when (member "Fira Code Symbol" (font-family-list))
    (add-hook 'prog-mode-hook #'fira-code-mode--enable)
    (add-hook 'text-mode-hook #'fira-code-mode--enable)
    ))

#+END_SRC

Setup for my JavaScript IDE.
#+BEGIN_SRC emacs-lisp
(use-package xref-js2
  :ensure t
  )

(use-package tern
  ;; Start with "npm install -g tern" in the terminal
  :ensure t
  :hook ((js2-mode . (lambda () (tern-mode 1))))
  )

(use-package company-tern
  :ensure t
  :config
  (add-company-backend 'company-tern)
  )

(use-package indium
  :ensure t
  )

(use-package js2-mode
  :ensure t
  :mode (("\\.js\\'" . js2-mode))
  )
#+END_SRC

Haskell is a functional language
ghc functions as a backend for Haskell, company-ghc hooks that into company, providing smart and real-time completion. Haskell-mode provides the from of the Haskell IDE. 
#+BEGIN_SRC emacs-lisp
(use-package ghc
  :ensure t
  :hook((haskell-mode . ghc-init))
  )

(use-package company-ghc
  :ensure t
  :after (ghc-mode company-mode)
  :config
  (add-company-backend 'company-ghc)
  (setq company-ghc-show-module t)
  )
(use-package haskell-mode
  :ensure t
  :config
  (custom-set-variables
   '(haskell-stylish-on-save t))
  )

#+END_SRC

C/C++ packages 
- irony acts as a handler
  - To install irony on a fresh computer, you need to have llvm installed. You then need to set the environmental variable "Clang_DIR" to the directory that contains "ClangConfig.cmake"
  - to find, use `pwd $(sudo find /usr/ ClangConfig.cmake)`
  - On mac I also tried this: "install_name_tool -change @rpath/libclang.dylib /usr/local/Cellar/llvm/8.0.1/Toolchains/LLVM8.0.1.xctoolchain/usr/lib/libclang.dylib ~/.emacs.d/irony/bin/irony-server"
#+BEGIN_SRC emacs-lisp
;; Enable company auto-complete
(use-package irony
  :ensure irony
  :hook ((c-mode objc-mode c++-mode) . irony-mode)
  :config
  (irony-cdb-autosetup-compile-options)
  (use-package clang-format
    :ensure t
    :config
    (setenv "Clang_DIR" "/usr/local/Cellar/llvm/8.0.1/Toolchains/LLVM8.0.1.xctoolchain/usr/lib/cmake/clang/")
    (setq clang-format-executable "/usr/local/opt/llvm/Toolchains/LLVM8.0.1.xctoolchain/usr/bin/clang-format")
    (add-hook 'before-save-hook (lambda ()
				  (when (eql major-mode 'c-mode)
				    (clang-format-buffer))
				  )
	      )
    )
  (use-package irony-eldoc
    :ensure t
    :config
    (irony-eldoc +1)
    )
  (use-package flycheck-irony
    :ensure t
    :after (flycheck)
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)
    (flycheck-irony-setup)
    (flycheck-mode +1)
    )
  (use-package company-irony
    :ensure t
    )
  (use-package company-irony-c-headers
    :ensure t
    )
  (defun c-compile-buffer ()
    (interactive)
    (let ((in buffer-file-name) (out (file-name-sans-extension buffer-file-name)))
      (compile (concat "cc '" in "' -o '" out "'"))))
  (local-set-key (kbd "C-c C-c") #'c-compile-buffer)
  (add-company-backend '(company-irony-c-headers company-irony))
  (my-prog-mode)
  (message "%s" "c/objc/c++ has been set up ")
  )
#+END_SRC
