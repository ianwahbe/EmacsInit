We hold the entire init file in Org mode to allow increased comments, along with better organization. This further gives
the easy ability to debug by disabling select components of the init. This is connected to a github page.

Idea: set a separate file with a set of variable assignments like specific paths, and names and passwords. Then have
this file load it to allow a secure posting.

First Steps
#+BEGIN_SRC emacs-lisp
;; Turn off mouse interface early in startup to avoid momentary display
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
;; No splash screen please ... jeez
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
;; The error bell is really annoying
(setq ring-bell-function 'ignore)
;;Fringes are not space efficiant
(set-fringe-mode 0)
#+END_SRC

We want emacs to work like the terminal version for maximum consistancy. This is where brew puts its formula, which is
my most common command line tool location.
#+BEGIN_SRC emacs-lisp
(setq exec-path (append exec-path '("/usr/local/bin"))) ;for internal functions
(setenv "PATH" (concat "/usr/local/bin/:" (getenv "PATH"))) ;for shell exicution

#+END_SRC

We ensure that packages are installed by using the use-package package, so we require that melpa is hooked up and that
use-package is installed
#+BEGIN_SRC emacs-lisp :tangle no
;;;-*- lexical-binding: t -*-
(require 'package)
(setq package-archives '(
			 ("elpa" . "http://tromey.com/elpa/")
			 ("gnu" . "http://elpa.gnu.org/packages/")
			 ("melpa" . "https://melpa.org/packages/")
			 ))
(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))
(unless (package--user-selected-p 'use-package)
  (package-install 'use-package)
  )
(eval-and-compile
  (require 'use-package))
#+END_SRC

[[https://github.com/raxod502/straight.el][straight.el]] is a package manager.
- A benefit is that packages installed are defined entirely by this file.
- unfortunately, straight.el is normally slower then package.el, because it checks for changes in source material. This
  can be overcome by setting check-for-modifications to be based on file saves, instead of actual changes.
#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(setq straight-check-for-modifications '(check-on-save find-when-checking))
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package) ;ensures both that use-package is installed and works with straight.el
#+END_SRC

We set the custom package to it's own file, instead of polluting our init, and we can't put it in init.el, as it's blown
away on tangle.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
(unless (file-exists-p custom-file) (write-region "" "" custom-file))
(load custom-file)
#+END_SRC

We apply the kaolin-galaxy theme if and only if we are using GUI emacs.
We setup preferences for the mode-line.
I turn on battery and time displays, setup smart-mode-line (ssl) and disable the menu-bar.
#+BEGIN_SRC emacs-lisp
(defun my-setup-graphics ()
      (use-package kaolin-themes
      :straight t
      :config
      (load-theme 'kaolin-galaxy t)
      )
  (setq display-time-default-load-average nil); must be assigned before (display-time-mode 1) is called
  (setq display-time-24hr-format t)
  (setq display-time-day-and-date t)
  (display-time-mode 1); does not change in real time, so all settings must be assigned before

  (display-battery-mode 1)

  (use-package smart-mode-line
    :straight t
    :hook (after-init . sml/setup)
    :config
    (setq sml/no-confirm-load-theme t)
    (setq sml/theme 'respectful) ;conforms to main emacs theme, set to nil to allow default colors
    (defface sml/charging ;this is much easier to see
      '((t :inherit sml/global :foreground "green")) "" :group 'smart-mode-line-faces)
    (add-to-list 'sml/replacer-regexp-list '("^~/Google Drive/" ":GDrive:") t) ;re replacement Google Drive -> GDrive
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox" ":DBox:") t) ;re replacement Drop Box -> DBox
    )

  (defun frame-reset-size ()
    "Sets the frame size back to the default"
    (interactive)
    (when (display-graphic-p)
      (set-frame-size (selected-frame) 80 36)))

  (global-set-key (kbd "s-t") 'make-frame) ;this allows cmd-t to be consistant
  (global-set-key (kbd "s-w") 'delete-frame)
  (global-set-key (kbd "s-<return>") 'toggle-frame-fullscreen)
  (global-set-key (kbd "M-s-<up>") 'toggle-frame-maximized)
  (global-set-key (kbd "M-s-<down>") 'frame-reset-size)
  )

(add-hook 'after-make-frame-functions
	  (lambda ()
	    (when window-system
	      (my-setup-graphics))))
(add-hook 'after-init-hook
	  (lambda () (when window-system
		  (my-setup-graphics))))

#+END_SRC

For setting up lisp-interaction-mode: the scratch buffer
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-interaction-mode-hook (lambda ()
					(local-set-key (kbd "C-j") 'backward-word)
					(local-set-key (kbd "C-S-j") 'eval-print-last-sexp)
					))
#+END_SRC



Sets up helpful universal variables.
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default sentence-end "[\\.\\?\\!] +")
#+END_SRC

I'm trying out EVIL, because reasons.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :straight t
  :bind
  ("C-\\" . 'evil-toggle)
  :init
  (setq evil-toggle-key (kbd ""))
  :bind (
	 ("C-\\" . 'evil-toggle)
	 :map evil-insert-state-map ("C-:" . 'evil-ex)
	 )
  :config
  (evil-mode -1)
  (evil-define-key nil evil-insert-state-map (kbd "C-d") 'delete-char)
  (defun evil-toggle (&optional prefix-p)
    (interactive "P")
    (if evil-mode
	(if prefix-p
	    (evil-mode 0)
	    (execute-kbd-macro (kbd "<escape>"))
	    )
      (if prefix-p
	  (evil-mode)
	(evil-ex)
	)))
  )

;;; Evil expects undo-tree
(use-package undo-tree
  :straight t
  :config
  (global-undo-tree-mode 0)
  )
#+END_SRC

Used to setup modes derived from prog-mode. We use my-prog-mode-called as a flag to indicate wither we load my-prog-mode
again. This is necessary because otherwise it gets called repeatedly.
#+BEGIN_SRC emacs-lisp
(defun my-prog-mode ()
  "Run as part of global prog-mode setup"
    (local-set-key (kbd "C-c q") 'comment-or-uncomment-region)
    (setq display-line-numbers t)
    (line-number-mode 0)
    (column-number-mode 1)
    (if (version<= "26.0.50" emacs-version)
	(display-line-numbers-mode 1) ; displays line numbers on the left
      (linum-mode 1) ; display-line-numbers-mode was added in v26, so if earlier, we default to linum-mode
      )
    (flyspell-prog-mode) ;this tells flyspell to not complain about variable names
    (eldoc-mode 1)
    (setq company-minimum-prefix-length 1) ;we want an active company for programming, as there are many variable names, and memory is hard
    (setq font-lock-maximum-decoration t) ;lots of syntax highlighting
    (subword-mode +1)
    (setq my-prog-mode-called t)
    (message "%s" (concat
		   "my-prog-mode was called successfully on major mode: "
		   (symbol-name major-mode)))
    )
(add-hook 'prog-mode-hook 'my-prog-mode)

#+END_SRC

Text-mode function
#+BEGIN_SRC emacs-lisp

(defun my-text-mode ()
  "A hook to call on text-mode init"
  (wc-mode +1)               ; provides a word count
  (flyspell-mode +1)         ; recognizes misspellings
  (visual-line-mode +1)      ; we want the words to wrap
  (setq tab-width 4)
  (superword-mode +1)
  (auto-fill-mode +1)
  (message "%s" "my-text-mode was called successfully.")
  )
(add-hook 'text-mode-hook 'my-text-mode)
#+END_SRC

Function to rename the file in the current buffer.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting. From http://whattheemacsd.com/"
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC


There is a collection of minor modes that trigger after other major modes load.
- saveplace has reopened files remember the mark position
- ace-window allows a multi-window mode (vim style)
- zoom changes window layout on crowded screens to show more of the selected window
- pending-delete-mode gives autodeletion on the region
- company-math gives a LaTeX style backend for LaTeX and markdown
- wc-mode provides a word count in the mode line
- electric operators provide spacing for prog modes that lack a util to prettify code
- define-word shows a word definition at point or on lookup
- magit is a git wrapper
- helm and helm-company provide fuzzy completion on system searches
- smartparens gives (semi) smart paired symbol insertion
#+BEGIN_SRC emacs-lisp

;; Save point position between sessions
(require 'saveplace)
(save-place-mode 1)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

(use-package expand-region
  :straight t
  :bind (("C-=" . 'er/expand-region))
  )

(use-package ace-window
  :straight t
  :bind (("M-o" . ace-window))
  )

(use-package zoom
  :straight t
  :config
  (zoom-mode 1)
  )

;; typing replaces the active region
(pending-delete-mode +1)

;;Word-count gives a total and diffrenced word count in the mode line
(use-package wc-mode
  :straight t
  :hook ((LaTeX-mode ess-mode markdown-mode) . wc-mode)
  :config
  (wc-mode 1)
  )

;;electric-operator adds spaces before and after opperator symbols
(use-package electric-operator
  :straight t
  :hook ((ess-mode) . electric-operator-mode)
  :config
  )

(use-package define-word
  :straight t
  :config
  (global-set-key (kbd "C-c d") 'define-word-at-point)
  (global-set-key (kbd "C-c D") 'define-word)
  )

(use-package magit
  :straight t
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  )

(use-package smartparens
  :straight t
  :config
  (sp-pair "(" ")" :unless '(sp-point-before-word-p))
  (add-hook 'c-mode-hook (lambda () (sp-pair "'" nil :actions :rem)))
  (add-hook 'emacs-lisp-mode-hook (lambda () (sp-pair "'" nil :actions :rem)))
  (smartparens-global-mode +1)
  )

#+END_SRC

I use helm for fuzzy searching among known options
#+BEGIN_SRC emacs-lisp

(use-package helm
  :straight t
  :config
  (helm-mode 1)
  (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  :bind (:map helm-occur-map
	      ("C-h c" . #'describe-key-briefly)
	      )
  )

;; for fast multi-file searches
(use-package helm-ag
  :straight t
  :config
  (defun search-selector (do-ag)
    (interactive "P")
    (if (equal do-ag 1) (helm-do-ag-this-file)
      (if (equal do-ag 2) (helm-do-ag-buffers)
	  (if do-ag (helm-do-ag-project-root)
	    (isearch-forward)))))
  (global-set-key (kbd "C-s") 'search-selector)
  )

(use-package helm-company
  :straight t
  :after (company helm)
  :config
  (define-key company-mode-map (kbd "C-;") 'helm-company)
  (define-key company-active-map (kbd "C-;") 'helm-company)
  )

#+END_SRC


yasnippet allows snippet expansion
Snippets are kept in the folder described by "yas-snippet-dirs"
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :straight t
  :after (company) ;due to company-mode
  :init
  (defun setup-yas-company ()
    (defvar company-mode/enable-yas t
      "Enable yasnippet for all backends.")

    (defun company-mode/backend-with-yas (backend)
      "addes company-yasnippet to \"backend\""
      (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
	  backend
	(append (if (consp backend) backend (list backend))
		'(:with company-yasnippet))))

    (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
    )
  :config
  (setup-yas-company)
  (yas-global-mode 1)
)
#+END_SRC


We maintain a list of common key-bindings to activate in all modes
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-r") 'scroll-down)
(global-set-key (kbd "C-v") 'scroll-up)
(global-set-key (kbd "C-l") 'forward-word)
(global-set-key (kbd "C-j") 'backward-word)
(global-set-key (kbd "M-f") 'forward-sentence)
(global-set-key (kbd "M-b") 'backward-sentence)
(global-set-key (kbd "C-z") 'ispell-word)
(global-set-key (kbd "M--") 'undo)
(global-set-key (kbd "C-M-n") (lambda () (interactive)
		  (ignore-errors (next-line 5))))
(global-set-key (kbd "C-M-p") (lambda () (interactive)
  		  (ignore-errors (previous-line 5))))
(global-set-key (kbd "C-<backspace>") (lambda () (interactive)
					(forward-word)
					(backward-kill-word 1)
					))
(global-set-key (kbd "M-c") 'capitalize-region)

(global-set-key (kbd "C-M-v") 'scroll-other-window-down)
(global-set-key (kbd "C-M-r") 'scroll-other-window)
(global-set-key (kbd "s-p") nil) ;used to be print
(global-set-key (kbd "s-o") nil) ;used to be ns-open-file-using-panel

#+END_SRC


Ido provides a great navigation experience with the find-file command.
Vlf stands for very large files and assists emacs with handling large files
#+BEGIN_SRC emacs-lisp

;; Interactively Do Things
(use-package ido
  :disabled
  :straight t
  :config
  (ido-mode t)
  )
(setq read-file-name-completion-ignore-case nil)

;;Very Large Files
(use-package vlf
  :straight t
  :config
  (require 'vlf-setup) ;not a seperate package, just pre-loading
  (custom-set-variables
   '(vlf-application 'dont-ask))
  )
#+END_SRC


Org mode provides a function text mode, so we give it many text mode type things.
Note: htmlize allows org-mode to publish to html more complex stuff like src blocks.
#+BEGIN_SRC emacs-lisp

  (use-package htmlize
	:straight t
	)

  (use-package org
	:straight t
	:defer t
	:bind (:map org-mode-map ("C-j" . 'backward-word))
	:config
	(setq org-src-window-setup 'current-window)
	(set-fill-column 120)
	(setq org-babel-python-command "python3")
	(org-babel-do-load-languages 'org-babel-load-languages
	 '((python . t) (emacs-lisp . t) (C . t)))
	(when (equal (buffer-file-name) ;the init.org file is special
			 (expand-file-name (concat user-emacs-directory "init.org")))
	  (my-prog-mode)
	  )
	(setq org-src-fontify-natively t)
	(setq org-src-tab-acts-natively t)
	(setq org-confirm-babel-evaluate nil)
	(setq org-src-preserve-indentation t)
	(defvar  *src-default-language* nil)
	(defun src-default-language ()
	  "Used to set a default src language for skeleton-src-blocks"
	  (interactive)
	  (setq *src-default-language* (read-string "Language: ")))
	(define-skeleton skeleton-src-block
	  "Inserts a SRC Block Letter into the buffer"
	  ""
	  "#+BEGIN_SRC " (if *src-default-language* *src-default-language* (skeleton-read "Language: ")) "\n"
	  "\n"
	  "#+END_SRC"
	  )
	(yas-activate-extra-mode 'text-mode)
	(message "%s" "Org mode called successfully.")
	)
#+END_SRC

Sets all backups to path to .emacs.d instead of cluttering the folder their in
#+BEGIN_SRC emacs-lisp
;; sets autosaves to one folder
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; Write backup files to own directory
(setq backup-directory-alist
      `(("." . ,(expand-file-name
		 (concat user-emacs-directory "backups")))))

;; Make backups of files, even when they're in version control
(setq vc-make-backup-files t)
#+END_SRC

Company is used for auto-completions. In the spirit of emacs, it can be customized for almost any language, but those
customizations are module specific. Here, we only call the main version.
#+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :init
  (defun add-company-backend (backend)
    "Is used to add company backends and include company-yasnippet with each backend"
    ;; (add-to-list 'company-backends `(,symbol-list . '(:with company-yasnippet)))
	(add-to-list 'company-backends (append (if (consp backend) backend (list backend))
		'(:with company-yasnippet)))
    )
  :config
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay 0.1) ; this makes company respond in real time (no delay)
  (setq company-dabbrev-downcase 0) ; this makes it so company correctly gives cases
  (global-company-mode t)
  :bind (:map company-active-map
  	      ("<return>" . nil)
	      ("RET" . nil)
  	      ("C-@" . #'company-complete-selection) ;also means space
	      ("C-SPC" . #'company-complete-selection)
	      ("C-<space>" . #'company-complete-selection)
	      ("M-p" . #'company-select-previous-or-abort)
	      ("M-n" . #'company-select-next-or-abort))
  )

(use-package company-flx
  :straight t
  :after (company)
  :config
  (company-flx-mode +1)
  )

;;Company-math provides auto-complete for math symbols
(use-package company-math
  :straight t
  :after (company (:any auctex markdown))
  :config
  (add-company-backend 'company-math)
  )
#+END_SRC


ESS (Emacs Speaks Statistics) is a major mode that I use to handle R. It could be extended to handle other S type
statistics languages in the future.
#+BEGIN_SRC emacs-lisp
(use-package ess
  :straight t
  :mode (("\\.r\\'" . ess-r-mode)
	 ("\\.Rmd\\'" . ess-r-mode)
	 ("\\.R\\'" . ess-r-mode))
  :config
  (setq inferior-ess-r-program "/usr/local/bin/R")
  ;; We assume the ability to generate graphs using a WindowsX(QuartsX) program.
  (setq ess-dialect "R")
  (setq ess-ask-for-ess-directory nil) ; directory defaults to whatever ess-directory-function returns
  (setq ess-directory-function nil) ; directory defaults to ess-directory
  (setq ess-directory nil) ; directory defaults to the directory of the opened file
  (add-hook 'inferior-ess-mode  'ess-execute-screen-options)
  :init
  (load "ess-autoloads")
  ; (require 'ess-site)
  )
#+END_SRC


I assign markdown to the appropriate extensions, and enable math-mode and wc-mode. I honestly don't use this much as
org-mode does most of what markdown does.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :straight t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
  	 ("\\.md\\'" . markdown-mode)
  	 ("\\.markdown\\'" . markdown-mode))
  :hook ((markdown-mode . (lambda ()
			    (yas-activate-extra-mode 'text-mode)
			    (display-line-numbers-mode -1)
			    (visual-line-mode 1))))
  :init
  (setq markdown-command "/usr/local/bin/multimarkdown")
  (setq markdown-enable-math t)
  :config
  (setq tab-width 4)
  (flyspell-mode +1)
  (message "%s" "Markdown mode was successfully called")
  )
#+END_SRC


I use sly as my lisp editor
#+BEGIN_SRC emacs-lisp
(use-package sly
  :straight t
  :defer t
  :mode (("\\.lisp\\'" . sly-mode))
  :hook ((sly-mode . (lambda () (prettify-symbols-mode +1)))) ;lambda is necessary to call with arguments
  :config
  ;; The check prevents setting a new editor at compile time
  (prettify-symbols-mode +1)
  (modify-syntax-entry ?- "w" lisp-mode-syntax-table)
  (lisp-mode)
  (if (string-suffix-p ".lisp" buffer-file-name)
      (setq inferior-lisp-program "/usr/local/bin/clisp"))
  (define-key sly-prefix-map (kbd "M-h") 'sly-documentation-lookup)
  (setq sly-lisp-implementations '(
	  (clisp ("/usr/local/bin/clisp"))
	  ))
  (setq sly-default-lisp 'clisp)
  (message "%s"  (concat "sly(slime) package loaded on major-mode: " (symbol-name major-mode)))
  (sly)
  )
#+END_SRC

Simple setup for emacs-lisp mode. Does very little.
#+BEGIN_SRC emacs-lisp
(defun my-emacs-lisp-mode ()
  "runs on 'emacs-lisp-mode-hook "
  (prettify-symbols-mode +1)
  (modify-syntax-entry ?- "w" emacs-lisp-mode-syntax-table)
  )
(add-hook 'emacs-lisp-mode-hook #'my-emacs-lisp-mode)
#+END_SRC

Configure rust, enabling rust-mode, cargo-mode, flymake-rust, and company-racer.
#+BEGIN_SRC emacs-lisp
;;; Rust Minor Modes

;; rust plugin to enable flymake
(use-package flymake-rust
  :disabled ;;FIXME
  :straight t
  :hook ((rust-mode . flymake-rust-load))
  :config
  (let ((rust-root-path (string-trim
			 (shell-command-to-string "rustc --print sysroot"))))
    (setq flymake-rust-use-cargo nil)
    (setq flymake-rust-executable (concat rust-root-path "/bin/cargo")))
  (message "%s" "flymake-rust has been enabled")
  )

;; Provides Cargo integration
(use-package cargo
  :straight t
  :hook (rust-mode . cargo-minor-mode)
  :config
  (cargo-minor-mode 1)
  (setq cargo-process--enable-rust-backtrace t)
  (setq cargo-process--command-build "build --verbose")
  (setq cargo-process--command-run "run --verbose")
  (message "%s" "cargo has been enabled")
  )

;; Compamny integration with racer (rust backend completion client)
(use-package racer
  :straight t
  :hook ((rust-mode . racer-mode)
	 (racer-mode-hook . eldoc-mode)
	 (racer-mode-hook . company-mode))
  :init
  (setq company-racer-executable "racer")
  :config
  (message "%s" "racer has been enabled.")
  )

;; Rust Major Mode
(use-package rust-mode
  :straight t
  :mode ("\\.rs\\'" . rust-mode)
  :init
  (setenv "PATH" (concat "~/.cargo/bin" ":"
			 (getenv "PATH")))
  (let ((rust-root-path (string-trim
		 (shell-command-to-string "rustc --print sysroot"))))
  (setq racer-rust-src-path
	(concat rust-root-path"/lib/rustlib/src/rust/src"))
  (setq rust-rustfmt-bin (concat rust-root-path "/bin/rustfmt")))
  :config
  (setq rust-format-on-save t)
  (message "%s" "Rust mode was called successfully")
  )

#+END_SRC

Setup elpy to provide auto-complete, highlighting, indent guides, along with an inferior shell for writing python.
#+BEGIN_SRC emacs-lisp
;;; Python Minor Modes

;;pyenv mode - Virtual Enviroment Manager
(use-package pyenv-mode
  :straight t
  :after (elpy)
  :init
  (setenv "WORKON_HOME" "~/.pyenv/versions/")
  :config
  (pyenv-mode +1)
  )

;; Indentation Guide
(use-package highlight-indent-guides
  :disabled
  :straight t
  :after (elpy)
  :config
  (highlight-indentation-mode 0)
  (setq highlight-indent-guides-method 'column); could be "character", "fill", "column"
  (setq highlight-indent-guides-character ?\|) ;sets character of the highlight, if in character mode
  (setq highlight-indent-guides-responsive nil); options: 'top, 'stack, this dictates if and how it responds to the cursor position
  (setq highlight-indent-guides-delay 0); respond immediately to the cursor
  (setq highlight-indent-guides-auto-enabled nil) ;this means that I can set colors, t means that it will guess based on theme
  (set-face-background 'highlight-indent-guides-odd-face "darkcyan")
  (set-face-background 'highlight-indent-guides-even-face "darkcyan")
  (set-face-foreground 'highlight-indent-guides-character-face "dimgrey")
  (highlight-indent-guides-mode 1); turn on mode
  )

;; Setup Python3 shell
(defun set-shell-python3 ()
  "Sets the shell to python3"
  (interactive)
  (setq python-shell-interpreter "python3")
  (setq python-shell-interpreter-args "-i")
  (with-eval-after-load 'python
    ;;This makes readline work in the interpreter
    (defun python-shell-completion-native-try ()
      "Return non-nil if can trigger native completion."
      (let ((python-shell-completion-native-enable t)
	    (python-shell-completion-native-output-timeout
	     python-shell-completion-native-try-output-timeout))
	(python-shell-completion-native-get-completions
	 (get-buffer-process (current-buffer))
	 nil "_"))))
  )

;; Setup iPython shell
(defun set-shell-ipython ()
  "Sets shell to ipython"
  (interactive)
  (setq python-shell-interpreter "ipython")
  (setq python-shell-interpreter-args "--simple-prompt -i")
  )

;;; Python Major Mode - Elpy
(use-package elpy
  :straight t
  :defer t
  :mode ("\\.py\\'" . python-mode)
  :hook ((python-mode . elpy-mode))
  :bind (:map elpy-mode-map
	      ("M-]" . 'elpy-nav-indent-shift-right)
	      ("M-[" . 'elpy-nav-indent-shift-left)
	      ("M-p" . 'elpy-nav-move-line-or-region-up)
	      ("M-n" . 'elpy-nav-move-line-or-region-down))
  :init
  (setq python-indent-guess-indent-offset t)
  (setq python-indent-guess-indent-offset-verbose nil)
  :config
  (add-hook 'before-save-hook #'elpy-format-code nil t)
  (elpy-enable)
  (setq elpy-rpc-backend "company")
  (setq indent-tabs-mode nil)
  (setq elpy-rpc-python-command "python3")
  (setq elpy-syntax-check-command "/usr/local/bin/flake8")
  (elpy-rpc-restart)
  (set-shell-python3)
  (message "%s" (concat "Python mode was called successfully. major-mode: "
			(symbol-name major-mode)))
  )
#+END_SRC

Sets up latex support along with a collection of skeletons for latex. This is also mostly replaced by org-mode
#+BEGIN_SRC emacs-lisp
(straight-use-package '(format-latex-mode :host github :repo "iwahbe/format-latex"))
(add-hook 'LaTeX-mode-hook 'format-latex-mode)


(use-package tex
  :straight auctex
  :defer t
  :mode ("\\.tex\\'" . LaTeX-mode)
  :hook ((LaTeX-mode . (lambda ()  (yas-activate-extra-mode 'text-mode)
			 (define-key LaTeX-mode-map (kbd "C-j")  'backward-word))))
  :config
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (visual-line-mode +1)
  (define-skeleton skeleton-math-letter
    "Inserts a latex Letter Outline into the buffer"
    "Title: "
    "\\documentclass[11pt, oneside]{article}\n"
    "\\usepackage{geometry}\n"
    "\\geometry{letterpaper}\n"
    "\\usepackage{graphicx}\n"
    "\\usepackage{amssymb}\n"
    "\\usepackage{enumitem}\n"
    "\\usepackage{amsmath}\n"
    "\\usepackage{amsfonts}\n"
    "\\makeatletter\n"
    "\\newcommand{\\zz}{\\mathbb{Z}}\n"
    "\\newcommand{\\rr}{\\mathbb{R}}\n"
    "\\newcommand{\\cc}{\\mathbb{C}}\n"
    "\\newcommand{\\nsum}{\\sum^n_{i=1}}\n"
    "\\newcommand{\\qq}{\\mathbb{Q}}\n"
    "\\newcommand{\\nn}{\\mathbb{N}}\n"
    "\\newcommand{\\exc}[1]{$ $\\\\\\noindent\\textbf{Problem #1}}\n"
    "\\newcommand{\\inpr}[2]{\\langle #1, #2\\rangle}\n"
    "\\newcommand{\\floor}[1]{\\lfloor #1 \\rfloor}\n"
    "\\newcommand{\\bmatrix}[1]{\\begin{bmatrix}#1\\end{bmatrix}}\n"
    "\\newcommand{\\fl}{{\\mathcal L}}\n"
    "\\newcommand{\\fu}{{\\mathcal U}}\n"
    "\\usepackage{tikz}\n"
    "\\title{" (skeleton-read "Title: ") "\n"
    "  \\\\ \\large " (skeleton-read "Class: ") "}\n"
    "\\author{" user-full-name "}\n"
    "\\date{" (skeleton-read "Date: ") "}\n"
    "\\begin{document}\n"
    "\\maketitle\n"
    "$\n"
    "$\\\\\n"
    -
    "\n\n\n\\end{document}"
    )
  (setenv "PATH" (concat "/Library/TeX/texbin/:" (getenv "PATH"))); to allow LaTeX output from org-mdoe
  (setq font-latex-fontify-script nil) ;disables inline subscripts and superscripts
  (add-to-list 'exec-path "/Library/TeX/texbin/" t)
  (setq tex--prettify-symbols-alist nil)
  (set-fill-column 100)

  (message "%s" "LaTeX-mode has been loaded successfully")
  )
#+END_SRC

We want init.org to have special behavior, specifically we want init.org to tangle to a .el file then byte compile for loading speed.
The part that performed the byte-compile is currently disabled as it caused problems with use-package.
#+BEGIN_SRC emacs-lisp
(defun tangle-init-call ()
  "Tangles this and only this file on save into init.el"
  (when (equal (buffer-file-name)
	       (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle-file buffer-file-name (concat user-emacs-directory "init.el"))
      ;; uncomment to byte compile init.el on save
      ;;(byte-compile-file (concat user-emacs-directory "init.el"))
      )))
(add-hook 'after-save-hook 'tangle-init-call)
#+END_SRC

I use a font called Fira-Code. This enables the font as well as the font's ligatures.
#+BEGIN_SRC emacs-lisp
(defun fira-code-mode--make-alist (list)
  "Generate prettify-symbols alist from LIST."
  (let ((idx -1))
    (mapcar
     (lambda (s)
       (setq idx (1+ idx))
       (let* ((code (+ #Xe100 idx))
          (width (string-width s))
          (prefix ())
          (suffix '(?\s (Br . Br)))
          (n 1))
     (while (< n width)
       (setq prefix (append prefix '(?\s (Br . Bl))))
       (setq n (1+ n)))
     (cons s (append prefix suffix (list (decode-char 'ucs code))))))
     list)))

(defconst fira-code-mode--ligatures
  '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    "!d!i!s!p!l!a!y!s!t!a!r!" ":" "+" "+" "*"))

(defvar fira-code-mode--old-prettify-alist)

(defun fira-code-mode--enable ()
  "Enable Fira Code ligatures in current buffer."
  (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
  (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
  (prettify-symbols-mode t))

(defun fira-code-mode--disable ()
  "Disable Fira Code ligatures in current buffer."
  (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
  (prettify-symbols-mode -1))

(define-minor-mode fira-code-mode
  "Fira Code ligatures minor mode"
  :lighter " Fira Code"
  (setq-local prettify-symbols-unprettify-at-point 'right-edge)
  (if fira-code-mode
      (fira-code-mode--enable)
    (fira-code-mode--disable)))

(defun fira-code-mode--setup ()
  "Setup Fira Code Symbols"
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

(provide 'fira-code-mode)


(when (and (window-system) (member "Fira Code" (font-family-list)))
  (set-frame-font "Fira Code")
  (when (member "Fira Code Symbol" (font-family-list))
    (add-hook 'prog-mode-hook #'fira-code-mode--enable)
    (add-hook 'text-mode-hook #'fira-code-mode--enable)
    ))

#+END_SRC

Setup for my JavaScript IDE.
#+BEGIN_SRC emacs-lisp
(use-package xref-js2
  :straight t
  )

(use-package tern
  ;; Start with "npm install -g tern" in the terminal
  :straight t
  :hook ((js2-mode . (lambda () (tern-mode 1))))
  )

(use-package company-tern
  :straight t
  :config
  (add-company-backend 'company-tern)
  )

(use-package indium
  :straight t
  )

(use-package js2-mode
  :straight t
  :mode (("\\.js\\'" . js2-mode))
  )
#+END_SRC

Haskell is a functional language
ghc functions as a backend for Haskell, company-ghc hooks that into company, providing smart and real-time completion. Haskell-mode provides the from of the Haskell IDE.
#+BEGIN_SRC emacs-lisp
(use-package ghc
  :straight t
  :hook((haskell-mode . ghc-init))
  )

(use-package company-ghc
  :straight t
  :after (ghc-mode company-mode)
  :config
  (add-company-backend 'company-ghc)
  (setq company-ghc-show-module t)
  )

(use-package haskell-mode
  :straight t
  :config
  (custom-set-variables
   '(haskell-stylish-on-save t))
  )
#+END_SRC

C/C++ packages
- irony acts as a handler
  - To install irony on a fresh computer, you need to have llvm installed. You then need to set the environmental
    variable "Clang_DIR" to the directory that contains "ClangConfig.cmake"
  - to find, use `pwd $(sudo find /usr/ ClangConfig.cmake)`
  - On mac I also tried this: "install_name_tool -change @rpath/libclang.dylib
    /usr/local/Cellar/llvm/8.0.1/Toolchains/LLVM8.0.1.xctoolchain/usr/lib/libclang.dylib
    ~/.emacs.d/irony/bin/irony-server"
#+BEGIN_SRC emacs-lisp
;; Enable company auto-complete
(use-package clang-format
  :straight t
  :after (irony)
  :config
  (setenv "Clang_DIR" "/usr/local/Cellar/llvm/9.0.0/Toolchains/LLVM9.0.0.xctoolchain/usr/lib/cmake/clang/")
  (setq clang-format-executable "/usr/local/opt/llvm/Toolchains/LLVM9.0.0.xctoolchain/usr/bin/clang-format")
  (setq clang-format-style "file")
  (defun clang-format-safe-buffer ()
    (interactive)
				(when (or (eql major-mode 'c-mode) (eql major-mode 'c++-mode))
				  (clang-format-buffer)))
  (add-hook 'before-save-hook 'clang-format-safe-buffer)
  )

(use-package company-irony-c-headers
  :straight t
  :after (irony)
  )

(use-package irony-eldoc
  :straight t
  :after (irony)
  :config
  (irony-eldoc +1)
  )

(use-package company-irony
  :straight t
  :after (:all irony company)
  )

(use-package flycheck-irony
  :straight t
  :after (:all flycheck irony)
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)
  (flycheck-irony-setup)
  (flycheck-mode +1)
  )

(use-package irony
  :straight irony
  :hook ((c-mode objc-mode c++-mode) . irony-mode)
  :config
  (irony-cdb-autosetup-compile-options)
  (defun c-compile-buffer ()
    "Compiles the current buffer with cc"
    (interactive)
    (let (
	  (in buffer-file-name)
	  (out (file-name-sans-extension buffer-file-name))
	  (compiler (pcase (file-name-extension (buffer-file-name))
		      ("cc" "g++ -std=c++17")
		      ("cpp" "g++ -std=c++17")
		      ("c" "cc")
		      )))
      (if compiler (compile (concat compiler " '" in "' -o '" out ".out'"))
	(message "%s" (concat "Cannot find compiler for exterion: " (file-name-extension (buffer-file-name))))
	)))
  (local-set-key (kbd "C-c C-c") #'c-compile-buffer)
  (add-company-backend '(company-irony-c-headers company-irony))
  (message "%s" "c/objc/c++ has been set up ")
  )
#+END_SRC

Auto-inserts c headers:
Binds "C-c C-f" to a function that inserts c function description yassnippet
#+BEGIN_SRC emacs-lisp
(defmacro incr (var) `(setq ,var (1+ ,var)))

(defun check-against-list (list-to-check bool-function)
  (if (funcall bool-function (car list-to-check))
      t
    (if (cdr list-to-check)
	(check-against-list (cdr list-to-check) bool-function)
      nil)))

(cl-defun concat-until-n  (lst &key (n 0) (before "") (after "") (count-from 0 count-from-p) (after-count "") (add-before-last ""))
  "Returns a concatonated list of list elements ignoring the last n with an optional count and surrounding text"
  (if (<= (length lst) n)
      ""   ; recursion base case
    (concat ;otherwise
     before
     (s-trim (car lst))
     (if (= (1- (length lst)) n) add-before-last nil)
     after
     (if count-from-p (int-to-string count-from) "")
     after-count
     (if count-from-p
	 (concat-until-n (cdr lst) :n n :before before :after after :count-from (1+ count-from) :after-count after-count :add-before-last add-before-last)
       (concat-until-n (cdr lst) :n n :before before :after after :after-count after-count :add-before-last add-before-last)))))

(defun remove-blank-lines (except num-blank &optional reverse)
  "Removes lines that start with \"excpet\" and blank lines until there are only \"num-blank\" blank lines above."
  (let ((blank-found 0) (exit nil) (direction (if reverse 1 -1)))
    (save-excursion
      (while (and (not exit) (< blank-found 1000))
	(if (equal (thing-at-point 'line t) "\n")
	    (progn
	      (incr blank-found)
	      (if (> blank-found num-blank)
		  (delete-blank-lines))
	      (forward-line direction))
	  (if (string-prefix-p except (thing-at-point 'line t))
	      (progn (forward-line direction) (setq blank-found 0))
	    (setq exit t)))))
    blank-found))

(defun scroll-down-blank ()
  "Scrolls the point down until encountering a non-blank line"
  (while (equal (thing-at-point 'line t) "\n")
    (forward-line 1)))

(defun remove-blank-up (prefix)
  "Deletes blank lines until there are 'prefix' left"
  (interactive "P")
  (let ((num-deleted (remove-blank-lines "//" 1  nil)))
    (if prefix
	(dotimes (a (- prefix 1)) (insert "\n")))
    (if (< num-deleted 2) nil (forward-line -1))))

(global-set-key (kbd "C-x M-p") 'remove-blank-up) ; eats whitespace between files

(defun c-func-description ()
  ;;skipping to the next line with content
  (scroll-down-blank)
  (beginning-of-line)
  (let* ((func-body-pair (split-string (thing-at-point 'line t) "{"))
	 (objects (split-string (car func-body-pair) "[\(,\)]")) (type-name (split-string (car objects) "[ ]+"))
	 (field-n 1)
	 (func-decorations (car (split-string (car (last type-name)) "[a-zA-Z-_:]" t)))
	 (func-undecorated (car (split-string (car (last type-name)) "[^a-zA-Z-_:]" t)))
	 )
    (defun field-n () (int-to-string field-n))
    ;; We assume that the first thing is the function name and everything else is an argument
    (yas-expand-snippet
     (concat "// " func-undecorated ": ${" (field-n) ":Describe Function}\n"
	     (if (and (check-against-list (cdr objects) (lambda (x) (string-match-p "[a-zA-Z]" x))) (not (equal (cadr objects) "void")))
		 (concat "//\n"
			 (concat-until-n (cdr objects) :n 1 :before "// " :after ": ${" :after-count ":Describe Argument}\n" :count-from 2)))
	     (if (or func-decorations (not (string-equal "void" (car type-name))))
		 (concat "//\n" "// return"
			 (concat-until-n type-name :n 1 :before " " :add-before-last func-decorations)
			 ": ${" (int-to-string (length objects)) ":Describe Return}\n\n")
	       "\n"))))
  (remove-blank-lines "//" 1))

(defun c-insert-func-description ()
  "Inserts a c-function description when called at or above a c function"
  (interactive)
  ;;Note: requires yasnippet to be installed
  (if (not (fboundp 'yas-expand-snippet))
      (message "%s" "c-func-description requires yas-expand-snippet")
    (c-func-description)))

(add-hook 'irony-mode-hook (lambda ()
			     (local-set-key (kbd "C-c C-f") 'c-insert-func-description)
			     (if (not (equal major-mode "c-mode"))
				 (yas-activate-extra-mode 'c-mode))))
#+END_SRC

Multiple cursors should be self-explanatory.
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :straight t
  :bind
  (("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c ," . mc/mark-all-like-this)
   (:map mc/keymap
	 ("<return>" . nil))) ;allows entry of <return> with multiple cursors
  )
#+END_SRC

CMake files suck, there should be a major mode for them:
#+BEGIN_SRC emacs-lisp
(use-package cmake-mode
  :straight t
  )
#+END_SRC

For writing assembly
#+BEGIN_SRC emacs-lisp
(defun my-asm-setup-mode-f ()
  (define-key asm-mode-map (kbd "C-j") 'backward-word)
  (defun asm-set-comment-char-internal (new-comment-char)
    "sets the new comment char to be c"
    ;;binds to asm-comment to c
    ;;unbinds the old asm-comment-char
    ;;update comment-char
    (let (old-comment-char asm-comment-char)
      (setq asm-comment-char new-comment-char)
      (define-key asm-mode-map (char-to-string new-comment-char) 'asm-comment)
      (if old-comment-char
      (define-key asm-mode-map (char-to-string old-comment-char) nil))
      (char-to-string new-comment-char)
      )
    )
)


(add-hook 'asm-mode-hook 'my-asm-setup-mode)

#+END_SRC


