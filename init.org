We hold the entire init file in Org mode to allow increased comments, 
along with better organization. This file lives in Github [[https://github.com/iwahbe/emacs][here]].

* Preliminary
This loads frameworks necessary for much of the following settings. 
This section should be used only for packages that must be loaded before everything else.
** Path Control
We want emacs to work like the terminal version for maximum consistancy. This is where brew puts its formula, which is
my most common command line tool location.
#+BEGIN_SRC emacs-lisp
(defun add-to-path (path-string &optional appendp)
  "Takes a path string, expands it, and adds it to exec path and PATH"
  (let* ((new-path (expand-file-name path-string))
	 (env-path (getenv "PATH")))

    (add-to-list 'exec-path new-path appendp)
    
    (if (not (member new-path (split-string env-path ":")))
	(if appendp
	    (setenv "PATH" (concat env-path ":" new-path))
	  (setenv "PATH" (concat new-path ":" env-path))))))

(add-to-path "/usr/local/bin")
#+END_SRC

** MELPA (disabled)
We ensure that packages are installed by using the use-package package, so we require that melpa is hooked up and that
use-package is installed
#+BEGIN_SRC emacs-lisp :tangle no
;;;-*- lexical-binding: t -*-
(require 'package)
(setq package-archives '(
			 ("elpa" . "http://tromey.com/elpa/")
			 ("gnu" . "http://elpa.gnu.org/packages/")
			 ("melpa" . "https://melpa.org/packages/")
			 ))
(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))
#+END_SRC

** Custom: Not in init.el
We set the custom package to it's own file, instead of polluting our init.el file.
Also, init.el is reset on tangle away on tangle.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
(unless (file-exists-p custom-file) (write-region "" "" custom-file))
(load custom-file)
#+END_SRC

** Package Manager: Straight
[[https://github.com/raxod502/straight.el][straight.el]] is a package manager.
- A benefit is that packages installed are defined entirely by this file.
- unfortunately, straight.el is normally slower then package.el, because it checks for changes in source material. This
  can be overcome by setting check-for-modifications to be based on file saves, instead of actual changes.
#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(setq straight-check-for-modifications '(check-on-save find-when-checking))
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package) ;ensures both that use-package is installed and works with straight.el
#+END_SRC

** Tangle init.org on save
We want init.org to have special behavior, specifically we want init.org to tangle to a .el file then byte compile for loading speed.
The part that performed the byte-compile is currently disabled as it caused problems with use-package.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar do-byte-compile nil "If this file should be byte-compiled after tangled"))

(defun tangle-init-call ()
  "Tangles this and only this file on save into init.el"
  (when (equal (buffer-file-name)
	       (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle-file buffer-file-name (concat user-emacs-directory "init.el"))
      (when do-byte-compile (byte-compile-file (concat user-emacs-directory "init.el"))))))

(add-hook 'after-save-hook 'tangle-init-call) 
#+END_SRC 


* Cosmetics
Purely cosmetic changes. Nothing else.
** Minimal Graphics
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :init
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  ;; No splash screen please ... jeez
  (setq inhibit-startup-message t)
  (blink-cursor-mode -1)
  ;; The error bell is really annoying
  (setq ring-bell-function 'ignore)
  ;;Fringes are not space efficiant
  (set-fringe-mode 0)
)
;; Turn off mouse interface early in startup to avoid momentary display
#+END_SRC

** Theme and Windowing
We apply the kaolin-galaxy theme if and only if we are using GUI emacs.
We setup preferences for the mode-line.
I turn on battery and time displays, setup smart-mode-line (ssl) and disable the menu-bar.
#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :straight t
  :when window-system
  :config
  (load-theme 'kaolin-galaxy t)
  )
(use-package smart-mode-line
  :straight t
  :init
  (sml/setup)
  :config
  (setq sml/no-confirm-load-theme t)
  (setq sml/theme 'respectful) ;conforms to main emacs theme, set to nil to allow default colors
  (setq sml/name-width 40)
  (setq sml/mode-width 'full)
  (defface sml/charging ;this is much easier to see
    '((t :inherit sml/global :foreground "green")) "" :group 'smart-mode-line-faces)
  (add-to-list 'sml/replacer-regexp-list '("^~/Google Drive/" ":GDrive:") t) ;re replacement Google Drive -> GDrive
  (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox" ":DBox:") t) ;re replacement Drop Box -> DBox
  )

(defun my-setup-graphics ()
  (setq display-time-default-load-average nil); must be assigned before (display-time-mode 1) is called
  (setq display-time-24hr-format t)
  (setq display-time-day-and-date t)
  (display-time-mode 1); does not change in real time, so all settings must be assigned before
  (display-battery-mode 1) ;display the battery in mode-line

  (defun frame-reset-size ()
    "Sets the frame size back to the default"
    (interactive)
    (when (display-graphic-p)
      (set-frame-size (selected-frame) 80 36)))

  ;; Frame manipulation bindings
  (global-set-key (kbd "s-t") 'make-frame)
  (global-set-key (kbd "s-w") 'delete-frame)
  (global-set-key (kbd "s-<return>") 'toggle-frame-fullscreen)
  (global-set-key (kbd "M-s-<up>") 'toggle-frame-maximized)
  (global-set-key (kbd "M-s-<down>") 'frame-reset-size)
  )

(add-hook 'after-make-frame-functions
	  (lambda ()
	    (when window-system
	      (my-setup-graphics))))
(add-hook 'after-init-hook
	  (lambda () (when window-system
		  (my-setup-graphics))))

#+END_SRC

** Fira-Code (graphics only)
I use a font called Fira-Code. This enables the font as well as the font's ligatures.
#+BEGIN_SRC emacs-lisp
(defun fira-code-mode--make-alist (list)
  "Generate prettify-symbols alist from LIST."
  (let ((idx -1))
    (mapcar
     (lambda (s)
       (setq idx (1+ idx))
       (let* ((code (+ #Xe100 idx))
          (width (string-width s))
          (prefix ())
          (suffix '(?\s (Br . Br)))
          (n 1))
     (while (< n width)
       (setq prefix (append prefix '(?\s (Br . Bl))))
       (setq n (1+ n)))
     (cons s (append prefix suffix (list (decode-char 'ucs code))))))
     list)))
;; Unwanted ligatures are replaced with untypeable charicters
(defconst fira-code-mode--ligatures
  (list "www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    (char-to-string 0); "{-"
    "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    (char-to-string 1); "x"
    ":" "+" "+" "*"))

(defvar fira-code-mode--old-prettify-alist)

(defun fira-code-mode--enable ()
  "Enable Fira Code ligatures in current buffer."
  (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
  (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
  (prettify-symbols-mode t))

(defun fira-code-mode--disable ()
  "Disable Fira Code ligatures in current buffer."
  (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
  (prettify-symbols-mode -1))

(define-minor-mode fira-code-mode
  "Fira Code ligatures minor mode"
  :lighter " Fira Code"
  (setq-local prettify-symbols-unprettify-at-point 'right-edge)
  (if fira-code-mode
      (fira-code-mode--enable)
    (fira-code-mode--disable)))

(defun fira-code-mode--setup ()
  "Setup Fira Code Symbols"
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

(provide 'fira-code-mode)


(when (and (window-system) (member "Fira Code" (font-family-list)))
  (set-frame-font "Fira Code")
  (when (member "Fira Code Symbol" (font-family-list))
    (add-hook 'prog-mode-hook #'fira-code-mode--enable)
    (add-hook 'text-mode-hook #'fira-code-mode--enable)
    ))

#+END_SRC


* Universal Alterations
These packages change the normal function of emacs in all major modes. 
** Universal Variables
Sets up helpful universal variables.
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default sentence-end "[\\.\\?\\!] +")
#+END_SRC

** Evil: Extensible VI Layer
I'm trying out EVIL, because reasons.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :straight t
  :bind
  ("C-\\" . 'evil-toggle)
  :init
  (setq evil-toggle-key (kbd ""))
  :bind (
	 ("C-\\" . 'evil-toggle)
	 :map evil-insert-state-map ("C-:" . 'evil-ex)
	 )
  :config
  (evil-mode -1)
  (evil-define-key nil evil-insert-state-map (kbd "C-d") 'delete-char)
  (defun evil-toggle (&optional prefix-p)
    (interactive "P")
    (if evil-mode
	(if prefix-p
	    (evil-mode 0)
	    (execute-kbd-macro (kbd "<escape>"))
	    )
      (if prefix-p
	  (evil-mode)
	(evil-ex)
	)))
  )

;;; Evil expects undo-tree
(use-package undo-tree
  :straight t
  :config
  (global-undo-tree-mode 0)
  )
#+END_SRC

** Yasnippet
yasnippet allows snippet expansion
Snippets are kept in the folder described by "yas-snippet-dirs"
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :straight t
  :after (company) ;due to company-mode
  :init
  (defun setup-yas-company ()
    (defvar company-mode/enable-yas t
      "Enable yasnippet for all backends.")

    (defun company-mode/backend-with-yas (backend)
      "addes company-yasnippet to \"backend\""
      (if (or (not company-mode/enable-yas) (and (listp backend)
						 (member 'company-yasnippet backend)))
	  backend
	(append (if (consp backend) backend (list backend))
		'(:with company-yasnippet))))

    (setq company-backends (mapcar #'company-mode/backend-with-yas
				   company-backends))
    )
  :config
  (setup-yas-company)
  (yas-global-mode 1)
  (define-key yas-minor-mode-map [(tab)] nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
)
#+END_SRC

** Rename-Current-Buffer Function
Function to rename the file in the current buffer.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  ;;From http://whattheemacsd.com/
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC

** FlyCheck
FlyCheck provides dynamic error highlighting from multiple backends.
Notes on use:
- "C-c ! v" provides a diagnosis for flycheck
- "C-c ! n" & "C-c ! p" navigate to errors
- "C-c ! l" provides an error list for the current buffer
- "C-c ! ?" provides information on any syntax checker
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :straight t
  :config
  (global-flycheck-mode +1)
  )
#+END_SRC

** Helm
I use helm for fuzzy searching among known options
#+BEGIN_SRC emacs-lisp

(use-package helm
  :straight t
  :config
  (helm-mode 1)
  (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  :bind (:map helm-occur-map
	      ("C-h c" . #'describe-key-briefly)
	      )
  )

;; for fast multi-file searches
(use-package helm-ag
  :straight t
  :after (helm)
  :config
  (defun search-selector (do-ag)
    (interactive "P")
    (if (equal do-ag 1) (helm-do-ag-this-file)
      (if (equal do-ag 2) (helm-do-ag-buffers)
	  (if do-ag (helm-do-ag-project-root)
	    (isearch-forward)))))
  (global-set-key (kbd "C-s") 'search-selector)
  )

(use-package helm-company
  :straight t
  :after (company helm)
  :config
  (define-key company-mode-map (kbd "C-;") 'helm-company)
  (define-key company-active-map (kbd "C-;") 'helm-company)
  )

#+END_SRC

** Ido (disabled)
Ido provides a great navigation experience with the find-file command.
#+BEGIN_SRC emacs-lisp

;; Interactively Do Things
(use-package ido
  :disabled
  :straight t
  :config
  (ido-mode t)
  )
(setq read-file-name-completion-ignore-case nil)
#+END_SRC

** Global Key Bindings
We maintain a list of common key-bindings to activate in all modes
#+BEGIN_SRC emacs-lisp
  (defun current-line-length ()
    (save-excursion
      (beginning-of-line)
      (let ((first-pos (point)))
	(end-of-line)
	(- (point) first-pos))
	))

  (global-set-key (kbd "C-r") 'scroll-down)
  (global-set-key (kbd "C-v") 'scroll-up)
  (global-set-key (kbd "C-l") 'forward-word)
  (global-set-key (kbd "C-j") 'backward-word)
  (global-set-key (kbd "M-f") 'forward-sentence)
  (global-set-key (kbd "M-b") 'backward-sentence)
  (global-set-key (kbd "C-z") 'ispell-word)
  (global-set-key (kbd "M--") 'undo)
  (global-set-key
   (kbd "C-M-n") (lambda (arg) (interactive "P")
		   (with-no-warnings
		     (next-line
		      (* 5 (if (equal arg nil) 1 arg))))))
  (global-set-key
   (kbd "C-M-p") (lambda (arg) (interactive "P")
		   (with-no-warnings
		     (next-line
		      (* -5 (if (equal arg nil) 1 arg))))))
  (global-set-key
   (kbd "C-<backspace>") (lambda (arg) (interactive "P")
			   (forward-word)
			   (backward-kill-word
			    (if (equal arg nil) 1 arg))))
  (global-set-key (kbd "M-c") 'capitalize-region)
  (global-set-key (kbd "C-M-v") 'scroll-other-window)
  (global-set-key (kbd "C-M-r") 'scroll-other-window-down)
  (global-set-key (kbd "s-p") nil) ;used to be print
  (global-set-key (kbd "s-o") nil) ;used to be ns-open-file-using-panel
  (eval-after-load 'doc-view
    (lambda () (define-key doc-view-mode-map (kbd "C-r") 'image-scroll-down)))

#+END_SRC

** Very Minor Modes
There is a collection of minor modes that trigger after other major modes load.
- saveplace has reopened files remember the mark position
- ace-window allows a multi-window mode (vim style)
- zoom changes window layout on crowded screens to show more of the selected window
- pending-delete-mode gives autodeletion on the region
- company-math gives a LaTeX style backend for LaTeX and markdown
- wc-mode provides a word count in the mode line
- electric operators provide spacing for prog modes that lack a util to prettify code
- define-word shows a word definition at point or on lookup
- helm and helm-company provide fuzzy completion on system searches
- smartparens gives (semi) smart paired symbol insertion
- VLF (Very Large Files)
#+BEGIN_SRC emacs-lisp

;; Save point position between sessions
(require 'saveplace)
(save-place-mode 1)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

(use-package expand-region
  :straight t
  :bind (("C-=" . 'er/expand-region))
  )

(use-package ace-window
  :straight t
  :bind (("M-o" . ace-window))
  )

(use-package zoom
  :straight t
  :config
  (zoom-mode 1)
  )

;; typing replaces the active region
(pending-delete-mode +1)

;;Word-count gives a total and diffrenced word count in the mode line
(use-package wc-mode
  :straight t
  :hook ((LaTeX-mode ess-mode markdown-mode) . wc-mode)
  :config
  (wc-mode 1)
  )

;;electric-operator adds spaces before and after opperator symbols
(use-package electric-operator
  :straight t
  :hook ((ess-mode) . electric-operator-mode)
  :config
  )

(use-package define-word
  :straight t
  :config
  (global-set-key (kbd "C-c d") 'define-word-at-point)
  (global-set-key (kbd "C-c D") 'define-word)
  )

(use-package smartparens
  :straight t
  :config
  (sp-pair "(" ")" :unless '(sp-point-before-word-p))
  (add-hook 'c-mode-hook (lambda () (sp-pair "'" nil :actions :rem)))
  (add-hook 'emacs-lisp-mode-hook (lambda () (sp-pair "'" nil :actions :rem)))
  (smartparens-global-mode +1)
  )

;;Very Large Files
(use-package vlf
  :straight t
  :config
  (require 'vlf-setup) ;not a seperate package, just pre-loading
  (custom-set-variables
   '(vlf-application 'dont-ask))
  )

#+END_SRC

** Git (Magit)
#+BEGIN_SRC emacs-lisp
(use-package magit
  :straight t
  :defer t
  :bind (("C-x g" . magit-status))
  )
(use-package magit-todos
  :straight t
  :after (:any magit)
  :config (magit-todos-mode +1)
)

#+END_SRC

** Company
Company is used for auto-completions. In the spirit of emacs, it can be customized for almost any language, but those
customizations are module specific. Here, we only call the main version.
#+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :init
  (defun add-company-backend (backend &optional add-to-back)
    "Is used to add company backends and include company-yasnippet with each backend"
    ;; (add-to-list 'company-backends `(,symbol-list . '(:with company-yasnippet)))
	(add-to-list 'company-backends (append (if (consp backend) backend (list backend))
					       '(:with company-yasnippet))
		     add-to-back)
    )
  :config
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay 0.1) ; this makes company respond in real time (no delay)
  (setq company-dabbrev-downcase 0) ; this makes it so company correctly gives cases
  (global-company-mode t)
  :bind (:map company-active-map
  	      ("<return>" . nil)
	      ("RET" . nil)
  	      ("C-@" . #'company-complete-selection) ;also means space
	      ("C-SPC" . #'company-complete-selection)
	      ("C-<space>" . #'company-complete-selection)
	      ("M-p" . #'company-select-previous-or-abort)
	      ("M-n" . #'company-select-next-or-abort))
  )

(use-package company-flx
  :straight t
  :after (company)
  :config
  (company-flx-mode +1)
  )

;;Company-math provides auto-complete for math symbols
(use-package company-math
  :straight t
  :after (company (:any auctex markdown))
  :config
  (add-company-backend 'company-math)
  )
#+END_SRC

** Multiple Cursors (GUI only)
Multiple cursors should be self-explanatory.
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :straight t
  :defer t
  :bind
  (("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c ," . mc/mark-all-like-this)
   (:map mc/keymap
	 ("<return>" . nil))) ;allows entry of <return> with multiple cursors
  )
#+END_SRC

** Backups (TODO: get backups working)
Sets all backups to path to .emacs.d instead of cluttering the folder their in
#+BEGIN_SRC emacs-lisp
;; sets autosaves to one folder
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; Write backup files to own directory
(setq backup-directory-alist
      `(("." . ,(expand-file-name
		 (concat user-emacs-directory "backups")))))

;; Make backups of files, even when they're in version control
(setq vc-make-backup-files t)
#+END_SRC

** Auto Insert
#+BEGIN_SRC emacs-lisp
(defun auto-insert-yas-expand()
  "Replace text in yasnippet template."
  (yas-expand-snippet (buffer-string) (point-min) (point-max)))

(use-package autoinsert
  :init
  (setq auto-insert-query nil)
  (setq auto-insert-directory (concat user-emacs-directory "auto-insert/"))
  (setq auto-insert-alist nil)
  (auto-insert-mode +1)
  :config  
  (define-auto-insert 'python-mode ["python-header.py" auto-insert-yas-expand])
)
#+END_SRC

** Fill Column Indicator
#+BEGIN_SRC emacs-lisp
(use-package whitespace-mode
  :hook ((prog-mode))
  :init
  (setq whitespace-line-column 80
   whitespace-style '(face lines-tail))
)
#+END_SRC


* Major Modes
This contains a set of mutually exclusive Major Modes packages, along with their associated settings. 
** Fundamental-Mode
For setting up lisp-interaction-mode: the scratch buffer
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-interaction-mode-hook (lambda ()
					(local-set-key (kbd "C-j") 'backward-word)
					(local-set-key (kbd "C-S-j") 'eval-print-last-sexp)
					))
#+END_SRC

** Programming-Mode
Used to setup modes derived from prog-mode. We use my-prog-mode-called as a flag to indicate wither we load my-prog-mode
again. This is necessary because otherwise it gets called repeatedly.
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :straight t
  :hook ((prog-mode . (lambda () (highlight-numbers-mode 1))))
  :config (set-face-foreground 'highlight-numbers-number "DarkOrchid2")
  )

(defun my-prog-mode ()
  "Run as part of global prog-mode setup"
  (local-set-key (kbd "C-c q") 'comment-or-uncomment-region)
  (setq display-line-numbers t)
  (line-number-mode 0)
  (column-number-mode 1)
  (if (version<= "26.0.50" emacs-version)
      (display-line-numbers-mode 1) ; displays line numbers on the left
    (linum-mode 1) ; display-line-numbers-mode was added in v26, so if earlier, we default to linum-mode
    )
  (flyspell-prog-mode) ;this tells flyspell to not complain about variable names

  (eldoc-mode 1)
  (setq company-minimum-prefix-length 1) ;we want an active company for programming, as there are many variable names, and memory is hard
  (setq font-lock-maximum-decoration t) ;lots of syntax highlighting
  (subword-mode +1)
  (setq my-prog-mode-called t)
  (message "%s" (concat
		 "my-prog-mode was called successfully on major mode: "
		 (symbol-name major-mode)))
  )
(add-hook 'prog-mode-hook 'my-prog-mode)

#+END_SRC

** Text-Mode
#+BEGIN_SRC emacs-lisp

(defun my-text-mode ()
  "A hook to call on text-mode init"
  (wc-mode +1)               ; provides a word count
  (flyspell-mode +1)         ; recognizes misspellings
  (visual-line-mode +1)      ; we want the words to wrap
  (setq tab-width 4)
  (message "%s" "my-text-mode was called successfully.")
  )
(add-hook 'text-mode-hook 'my-text-mode)
#+END_SRC

** Org-Mode
Org mode provides a function text mode, so we give it many text mode type things.
Note: htmlize allows org-mode to publish to html more complex stuff like src blocks.
#+BEGIN_SRC emacs-lisp

  (use-package htmlize
	:straight t
	:after (org)
	)

  (use-package org
	:straight t
	:defer t
	:bind (:map org-mode-map ("C-j" . 'backward-word))
	:config
	(setq org-src-window-setup 'current-window)
	(set-fill-column 120)
	(setq org-babel-python-command "python3")
	(org-babel-do-load-languages 'org-babel-load-languages
	 '((python . t) (emacs-lisp . t) (C . t)))
	(when (equal (buffer-file-name) ;the init.org file is special
			 (expand-file-name (concat user-emacs-directory "init.org")))
	  (my-prog-mode)
	  )
	(setq org-src-fontify-natively t)
	(setq org-src-tab-acts-natively t)
	(setq org-confirm-babel-evaluate nil)
	(setq org-src-preserve-indentation t)
	(defvar  *src-default-language* nil)
	(defun src-default-language ()
	  "Used to set a default src language for skeleton-src-blocks"
	  (interactive)
	  (setq *src-default-language* (read-string "Language: ")))
	(define-skeleton skeleton-src-block
	  "Inserts a SRC Block Letter into the buffer"
	  ""
	  "#+BEGIN_SRC " (if *src-default-language* *src-default-language* (skeleton-read "Language: ")) "\n"
	  "\n"
	  "#+END_SRC"
	  )
	(yas-activate-extra-mode 'text-mode)
	(message "%s" "Org mode called successfully.")
	)
#+END_SRC

** R
ESS (Emacs Speaks Statistics) is a major mode that facilitates S type statistics languages.
#+BEGIN_SRC emacs-lisp
(use-package ess
  :straight t
  :mode (("\\.r\\'" . ess-r-mode)
	 ("\\.Rmd\\'" . ess-r-mode)
	 ("\\.R\\'" . ess-r-mode))
  :config
  (setq inferior-ess-r-program "/usr/local/bin/R")
  ;; We assume the ability to generate graphs using a WindowsX(QuartsX) program.
  (setq ess-dialect "R")
  (setq ess-ask-for-ess-directory nil) ; directory defaults to whatever ess-directory-function returns
  (setq ess-directory-function nil) ; directory defaults to ess-directory
  (setq ess-directory nil) ; directory defaults to the directory of the opened file
  (add-hook 'inferior-ess-mode  'ess-execute-screen-options)
  :init
  (load "ess-autoloads")
  )
#+END_SRC

** Markdown-Mode
I assign markdown to the appropriate extensions, and enable math-mode and wc-mode. I honestly don't use this much as
org-mode does most of what markdown does.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :straight t
  :defer t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
  	 ("\\.md\\'" . markdown-mode)
  	 ("\\.markdown\\'" . markdown-mode))
  :hook ((markdown-mode . (lambda ()
			    (yas-activate-extra-mode 'text-mode)
			    (display-line-numbers-mode -1)
			    (visual-line-mode 1))))
  :init
  (setq markdown-command "/usr/local/bin/multimarkdown")
  (setq markdown-enable-math t)
  :config
  (add-to-path "/Library/TeX/texbin/" t)
  (message "%s" "Markdown mode was successfully called")
  )
#+END_SRC

** Lisp
I use sly as my lisp editor
#+BEGIN_SRC emacs-lisp
(use-package sly
  :straight t
  :defer t
  :mode (("\\.lisp\\'" . sly-mode))
  :hook ((sly-mode . (lambda () (prettify-symbols-mode +1)))) ;lambda is necessary to call with arguments
  :config
  ;; The check prevents setting a new editor at compile time
  (prettify-symbols-mode +1)
  (modify-syntax-entry ?- "w" lisp-mode-syntax-table)
  (lisp-mode)
  (if (string-suffix-p ".lisp" buffer-file-name)
      (setq inferior-lisp-program "/usr/local/bin/clisp"))
  (define-key sly-prefix-map (kbd "M-h") 'sly-documentation-lookup)
  (setq sly-lisp-implementations '(
	  (clisp ("/usr/local/bin/clisp"))
	  ))
  (setq sly-default-lisp 'clisp)
  (message "%s"  (concat "sly(slime) package loaded on major-mode: " (symbol-name major-mode)))
  (sly)
  )
#+END_SRC

** Emacs-Lisp
Simple setup for emacs-lisp mode. Does very little.
#+BEGIN_SRC emacs-lisp
(defun my-emacs-lisp-mode ()
  "runs on 'emacs-lisp-mode-hook "
  (prettify-symbols-mode +1)
  (modify-syntax-entry ?- "w" emacs-lisp-mode-syntax-table)
  )
(add-hook 'emacs-lisp-mode-hook #'my-emacs-lisp-mode)
#+END_SRC

** Rust
Configure rust, enabling rust-mode, cargo-mode, flycheck-rust, and company-racer.
#+BEGIN_SRC emacs-lisp
(use-package flycheck-rust
  :straight t
  :hook (rust-mode . flycheck-rust-setup)
  :config
  (flycheck-mode +1)
  (flycheck-rust-setup)
  (message "%s" "flycheck-rust has been enabled")
  )

;; Provides Cargo integration
(use-package cargo
  :straight t
  :hook (rust-mode . cargo-minor-mode)
  :config
  (cargo-minor-mode 1)
  (setq cargo-process--enable-rust-backtrace t)
  (setq cargo-process--command-build "build --verbose")
  (setq cargo-process--command-run "run --verbose")
  (message "%s" "cargo has been enabled")
  )

;; Compamny integration with racer (rust backend completion client)
(use-package racer
  :straight t
  :hook ((rust-mode . racer-mode))
  :init
  (setq company-racer-executable "racer")
  :config
  (company-mode +1)
  (eldoc-mode +1)
  (message "%s" "racer has been enabled.")
  )

;; Rust Major Mode
(use-package rust-mode
  :straight t
  :mode ("\\.rs\\'" . rust-mode)
  :init
  (add-to-path "~/.cargo/bin")
  (let ((rust-root-path (string-trim
		 (shell-command-to-string "rustc --print sysroot"))))
  (setq racer-rust-src-path
	(concat rust-root-path "/lib/rustlib/src/rust/src"))
  (setq rust-rustfmt-bin (concat rust-root-path "/bin/rustfmt")))
  :config
  (setq rust-format-on-save t
	whitespace-line-column 98)
  (message "%s" "Rust mode was called successfully")
  )

#+END_SRC

** Python
Setup elpy to provide auto-complete, highlighting, indent guides, along with an inferior shell for writing python.
#+BEGIN_SRC emacs-lisp
;;; Python Minor Modes

;;pyenv mode - Virtual Enviroment Manager
(use-package pyenv-mode
  :straight t
  :after (elpy)
  :init
  (setenv "WORKON_HOME" "~/.pyenv/versions/")
  :config
  (pyenv-mode +1)
  )

;; Indentation Guide
(use-package highlight-indent-guides
  :disabled
  :straight t
  :after (elpy)
  :config
  (highlight-indentation-mode 0)
  ;; Options: "character", "fill", "column"
  (setq highlight-indent-guides-method 'column)
  ;;;sets character of the highlight, if in character mode
  (setq highlight-indent-guides-character ?\|)
  ;; Options: 'top, 'stack
  (setq highlight-indent-guides-responsive nil)
  (setq highlight-indent-guides-delay 0); respond immediately to the cursor
  ;; Sets if colors are controlled by theme
  (setq highlight-indent-guides-auto-enabled nil)
  (set-face-background 'highlight-indent-guides-odd-face "darkcyan")
  (set-face-background 'highlight-indent-guides-even-face "darkcyan")
  (set-face-foreground 'highlight-indent-guides-character-face "dimgrey")
  (highlight-indent-guides-mode +1)
  )

;; Setup Python3 shell
(defun set-shell-python3 ()
  "Sets the shell to python3"
  (interactive)
  (setq python-shell-interpreter "python3")
  (setq python-shell-interpreter-args "-i")
  (with-eval-after-load 'python
    ;;This makes readline work in the interpreter
    (defun python-shell-completion-native-try ()
      "Return non-nil if can trigger native completion."
      (let ((python-shell-completion-native-enable t)
	    (python-shell-completion-native-output-timeout
	     python-shell-completion-native-try-output-timeout))
	(python-shell-completion-native-get-completions
	 (get-buffer-process (current-buffer))
	 nil "_"))))
  )

;; Setup iPython shell
(defun set-shell-ipython ()
  "Sets shell to ipython"
  (interactive)
  (setq python-shell-interpreter "ipython")
  (setq python-shell-interpreter-args "--simple-prompt -i")
  )

;;; Python Major Mode - Elpy
(use-package elpy
  :straight t
  :defer t
  :mode ("\\.py\\'" . python-mode)
  :hook ((python-mode . elpy-mode))
  :bind (:map elpy-mode-map
	      ("M-]" . 'elpy-nav-indent-shift-right)
	      ("M-[" . 'elpy-nav-indent-shift-left)
	      ("M-p" . 'elpy-nav-move-line-or-region-up)
	      ("M-n" . 'elpy-nav-move-line-or-region-down))
  :init
  (setq python-indent-guess-indent-offset t)
  (setq python-indent-guess-indent-offset-verbose nil)
  :config
  (add-hook 'before-save-hook #'elpy-format-code nil t)
  (elpy-enable)
  (setq elpy-rpc-backend "company"
	fill-column 80
	indent-tabs-mode nil
	elpy-rpc-python-command "python3"
	elpy-syntax-check-command "/usr/local/bin/flake8")
  (elpy-rpc-restart)
  (set-shell-python3)
  (message "%s" (concat "Python mode was called successfully. major-mode: "
			(symbol-name major-mode)))
  )
#+END_SRC

** LaTeX
Sets up latex support along with a collection of skeletons for latex. This is also mostly replaced by org-mode
#+BEGIN_SRC emacs-lisp
(straight-use-package '(format-latex-mode
			:host github :repo "iwahbe/format-latex"))
(add-hook 'LaTeX-mode-hook 'format-latex-mode)


(use-package tex
  :straight auctex
  :defer t
  :mode ("\\.tex\\'" . LaTeX-mode)
  :hook ((LaTeX-mode . (lambda ()  (yas-activate-extra-mode 'text-mode)
			 (define-key LaTeX-mode-map (kbd "C-j")  'backward-word)
			 )))
  :config
  (setq TeX-auto-save t
	TeX-parse-self t
	font-latex-fontify-script nil
	tex--prettify-symbols-alist nil)
  (visual-line-mode +1)
  (load (expand-file-name (concat user-emacs-directory "LaTeX_skeletons.el")))
  (add-to-path "/Library/TeX/texbin/" t)
  (set-fill-column 100)
  (message "%s" "LaTeX-mode has been loaded successfully")
  )
#+END_SRC

** Javascript
Setup for my JavaScript IDE.
#+BEGIN_SRC emacs-lisp
(use-package xref-js2
  :after (js2-mode)
  :straight t
  )

(use-package tern
  ;; Start with "npm install -g tern" in the terminal
  :after (js2-mode)
  :straight t
  :hook ((js2-mode . (lambda () (tern-mode 1))))
  )

(use-package company-tern
  :after (js2-mode)
  :straight t
  :config
  (add-company-backend 'company-tern)
  )

(use-package indium
  :after (js2-mode)
  :straight t
  )

(use-package js2-mode
  :straight t
  :mode (("\\.js\\'" . js2-mode))
  )
#+END_SRC

** Haskell
Haskell is a functional language
ghc functions as a backend for Haskell, company-ghc hooks that into company, providing smart and real-time completion. Haskell-mode provides the from of the Haskell IDE.
#+BEGIN_SRC emacs-lisp
(use-package ghc
  :straight t
  :hook((haskell-mode . ghc-init))
  )

(use-package company-ghc
  :straight t
  :after (ghc-mode company-mode)
  :config
  (add-company-backend 'company-ghc)
  (setq company-ghc-show-module t)
  )

(use-package haskell-mode
  :straight t
  :defer t
  :config
  (custom-set-variables
   '(haskell-stylish-on-save t))
  )
#+END_SRC

** C/C++

#+TITLE: C/C++ No matter what
#+BEGIN_SRC emacs-lisp
;; Enable company auto-complete

(use-package cmake-ide
  :straight t
  :hook (c-mode c++-mode objc-mode)
  :config
  (setq cmake-ide-build-dir (concat (cide--locate-project-dir) "build"))
  (cmake-ide-setup)
  (cmake-ide-run-cmake)
  (local-set-key (kbd "C-c C-c")  'cmake-ide-compile)
  )

(use-package clang-format
  :straight t
  :defer
  :after (cmake-ide)
  :config
  (setenv "Clang_DIR" "/usr/local/Cellar/llvm/9.0.0/Toolchains/LLVM9.0.1.xctoolchain/usr/lib/cmake/clang/")
  (setq clang-format-executable "/usr/local/opt/llvm/Toolchains/LLVM9.0.1.xctoolchain/usr/bin/clang-format")
  (setq clang-format-style "file")
  (defun clang-format-safe-buffer ()
    (interactive)
    (when (or (eql major-mode 'c-mode) (eql major-mode 'c++-mode))
      (clang-format-buffer)))
  (add-hook 'before-save-hook 'clang-format-safe-buffer)
  )


#+END_SRC

CQuery is the a completion and indexing framework for C/C++ programs. 
- it provides company-completion through company-lsp
- It provides syntax highlighting through 

#+TITLE: cquery
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :straight t
  :hook ((c-mode c++-mode objc-mode) . lsp-mode)
  :commands (lsp lsp-deferred)
   )

(use-package lsp-ui
  :straight t
  :disabled
  :hook ((lsp-mode-hook . lsp-ui-mode)
	 (prog-mode-hook . flycheck-mode))
  :config
  (lsp-ui-doc-mode -1)
  )

(use-package company-lsp
  :straight t
  :after (lsp-mode company-mode)
  :config
  (push 'company-lsp company-backends)
  )

(use-package cquery
  :straight t
  :after (lsp-mode)
  :config
  (setq cquery-executable "/usr/local/bin/cquery")
  (setq cquery-sem-highlight-method 'font-lock)
  (lsp)
)
#+END_SRC

rtags
- Is a complicated process, that requires a running a cpp program in a
  separate deamon. It also requires building upon install.
- The separate process is spun up by cmake-ide on setup.
- We assume that rtags was build in it's default straight repo
#+TITLE: rtags
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-rtags
  :straight t
  :after (:all rtags company)
  :config
  (setq rtags-path (concat user-emacs-directory "straight/repos/rtags/bin/"))
  (add-company-backend 'company-rtags)
  )

(use-package rtags
  :after (cmake-ide)
  :straight t
  :config 
  (cmake-ide-maybe-start-rdm)
  )
#+END_SRC

- To install irony on a fresh computer, you need to have llvm installed. You then need to set the environmental
  variable "Clang_DIR" to the directory that contains "ClangConfig.cmake"
- to find, use `pwd $(sudo find /usr/ ClangConfig.cmake)`
- On mac I also tried this: "install_name_tool -change @rpath/libclang.dylib
  /usr/local/Cellar/llvm/8.0.1/Toolchains/LLVM8.0.1.xctoolchain/usr/lib/libclang.dylib
  ~/.emacs.d/irony/bin/irony-server"

#+TITLE: Irony-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-irony-c-headers
  :straight t
  :after (irony)
  :config
  (add-company-backend '(company-irony-c-headers))
  )

(use-package irony-eldoc
  :straight t
  :after (irony)
  :config
  (irony-eldoc +1)
  )

(use-package company-irony
  :straight t
  :after (:all irony company)
  :config
  (setq company-irony-ignore-case 'smart)
  (add-company-backend '(company-irony))
  )

(use-package flycheck-irony
  :straight t
  :after (:all irony)
  :hook ((irony-mode-hook . flycheck-irony-setup))
  :config
  (flycheck-mode +1)
  )

(use-package irony
  :straight irony
  :hook ((c-mode objc-mode c++-mode) . irony-mode)
  :config
  (message "%s" "c/objc/c++ has been set up ")
  )
#+END_SRC

Auto-inserts c headers:
Binds "C-c C-f" to a function that inserts c function description yassnippet
#+BEGIN_SRC emacs-lisp
(defmacro incr (var) `(setq ,var (1+ ,var)))

(defun check-against-list (list-to-check bool-function)
  (if (funcall bool-function (car list-to-check))
      t
    (if (cdr list-to-check)
	(check-against-list (cdr list-to-check) bool-function)
      nil)))

(cl-defun concat-until-n
    (lst &key (n 0) (before "") (after "") 
	 (count-from 0 count-from-p) (after-count "") (add-before-last ""))
  "Returns a concatonated list of list elements ignoring the last n with an optional count and surrounding text"
  (if (<= (length lst) n)
      ""   ; recursion base case
    (concat ;otherwise
     before
     (s-trim (car lst))
     (if (= (1- (length lst)) n) add-before-last nil)
     after
     (if count-from-p (int-to-string count-from) "")
     after-count
     (if count-from-p
	 (concat-until-n (cdr lst)
			 :n n :before before :after after
			 :count-from (1+ count-from)
			 :after-count after-count
			 :add-before-last add-before-last)
       (concat-until-n (cdr lst)
		       :n n :before before
		       :after after :after-count after-count
		       :add-before-last add-before-last)))))

(defun remove-blank-lines (except num-blank &optional reverse)
  "Removes lines that start with \"excpet\" and blank lines until there are only \"num-blank\" blank lines above."
  (let ((blank-found 0) (exit nil) (direction (if reverse 1 -1)))
    (save-excursion
      (while (and (not exit) (< blank-found 1000))
	(if (equal (thing-at-point 'line t) "\n")
	    (progn
	      (incr blank-found)
	      (if (> blank-found num-blank)
		  (delete-blank-lines))
	      (forward-line direction))
	  (if (string-prefix-p except (thing-at-point 'line t))
	      (progn (forward-line direction) (setq blank-found 0))
	    (setq exit t)))))
    blank-found))

(defun scroll-down-blank ()
  "Scrolls the point down until encountering a non-blank line"
  (while (equal (thing-at-point 'line t) "\n")
    (forward-line 1)))

(defun remove-blank-up (prefix)
  "Deletes blank lines until there are 'prefix' left"
  (interactive "P")
  (let ((num-deleted (remove-blank-lines "//" 1  nil)))
    (if prefix
	(dotimes (a (- prefix 1)) (insert "\n")))
    (if (< num-deleted 2) nil (forward-line -1))))

(global-set-key (kbd "C-x M-p") 'remove-blank-up) ; eats whitespace between files

(defun c-func-description ()
  ;;skipping to the next line with content
  (scroll-down-blank)
  (beginning-of-line)
  (let* ((func-body-pair (split-string (thing-at-point 'line t) "{"))
	 (objects (split-string (car func-body-pair) "[\(,\)]")) (type-name (split-string (car objects) "[ ]+"))
	 (field-n 1)
	 (func-decorations (car (split-string (car (last type-name)) "[a-zA-Z-_:]" t)))
	 (func-undecorated (car (split-string (car (last type-name)) "[^a-zA-Z-_:]" t)))
	 )
    (defun field-n () (int-to-string field-n))
    ;; We assume that the first thing is the function name and everything else is an argument
    (yas-expand-snippet
     (concat "// " func-undecorated ": ${" (field-n) ":Describe Function}\n"
	     (if (and (check-against-list (cdr objects) (lambda (x) (string-match-p "[a-zA-Z]" x))) (not (equal (cadr objects) "void")))
		 (concat "//\n"
			 (concat-until-n (cdr objects) :n 1 :before "// " :after ": ${" :after-count ":Describe Argument}\n" :count-from 2)))
	     (if (or func-decorations (not (string-equal "void" (car type-name))))
		 (concat "//\n" "// return"
			 (concat-until-n type-name :n 1 :before " " :add-before-last func-decorations)
			 ": ${" (int-to-string (length objects)) ":Describe Return}\n\n")
	       "\n"))))
  (remove-blank-lines "//" 1))

(defun c-insert-func-description ()
  "Inserts a c-function description when called at or above a c function"
  (interactive)
  ;;Note: requires yasnippet to be installed
  (if (not (fboundp 'yas-expand-snippet))
      (message "%s" "c-func-description requires yas-expand-snippet")
    (c-func-description)))

(add-hook 'c-mode-hook (lambda ()
			     (local-set-key (kbd "C-c C-f") 'c-insert-func-description)
			     (if (not (equal major-mode "c-mode"))
				 (yas-activate-extra-mode 'c-mode))))
(add-hook 'c++-mode-hook (lambda ()
			     (local-set-key (kbd "C-c C-f") 'c-insert-func-description)
			     (if (not (equal major-mode "c-mode"))
				 (yas-activate-extra-mode 'c-mode))))
(add-hook 'objc-mode-hook (lambda ()
			     (local-set-key (kbd "C-c C-f") 'c-insert-func-description)
			     (if (not (equal major-mode "c-mode"))
				 (yas-activate-extra-mode 'c-mode))))
#+END_SRC

** CMake
CMake files suck, there should be a major mode for them:
#+BEGIN_SRC emacs-lisp
(use-package cmake-mode
  :defer t
  :straight t
  )
#+END_SRC

** ASM (assembly)
For writing assembly
#+BEGIN_SRC emacs-lisp
(defun my-asm-setup-mode ()
  (define-key asm-mode-map (kbd "C-j") 'backward-word)
  )

(add-hook 'asm-mode-hook 'my-asm-setup-mode)
#+END_SRC

** ansi-term
#+BEGIN_SRC emacs-lisp
(use-package term
  ;; Note: No ensure
  :bind (:map term-mode-map
	      ("M-p" . term-send-up)
	      ("M-n" . term-send-down)
	      ("C-y" . term-paste))
  )
#+END_SRC



